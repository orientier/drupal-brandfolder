<?php

/**
 * @file
 * Contains brandfolder.module.
 */

use Drupal\brandfolder\Plugin\media\Source\BrandfolderImage;
use Drupal\Core\Routing\RouteMatchInterface;
use Brandfolder\Brandfolder;
use Drupal\Core\Render\Element;
use Drupal\field\Entity\FieldStorageConfig;
use Drupal\file\Entity\File;
use Drupal\Core\Database;
use Drupal\media\MediaInterface;
use Drupal\media\MediaTypeInterface;

/**
 * Brandfolder helper function.
 *
 * Helper function to get a Brandfolder object that can be used to interact with
 * the Brandfolder API.
 *
 * @param string|null $api_key
 *   If provided, an API key to use when connecting to Brandfolder. If not
 *   provided, the default API key set in the module configuration will be used.
 *
 * @return bool|object
 *   A \Brandfolder\Brandfolder object for interacting with the Brandfolder SDK,
 *   or FALSE on failure.
 */
function brandfolder_api(string $api_key = NULL) {
  // Get the default API key from module configuration if none is explicitly
  // provided.
  if (is_null($api_key)) {
    $api_key = \Drupal::config('brandfolder.settings')->get('api_key');
  }
  if (empty($api_key)) {
    return FALSE;
  }

  // Set Brandfolder and collection based on module config if present (NULL
  // otherwise).
  $default_brandfolder = \Drupal::config('brandfolder.settings')->get('default_brandfolder');
  $bf = new Brandfolder($api_key, $default_brandfolder);

  $default_collection = \Drupal::config('brandfolder.settings')->get('default_collection');
  if ($default_collection) {
    // @todo: getter/setter methods.
    $bf->default_collection_id = $default_collection;
  }

  return $bf;
}

/**
 * Implements hook_help().
 */
function brandfolder_help($route_name, RouteMatchInterface $route_match) {
  switch ($route_name) {
    // Main module help for the Brandfolder module.
    case 'help.page.brandfolder':
      $output = '';
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('Allows Drupal developers to easily integrate with a Brandfolder account.') . '</p>';

      return $output;
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function brandfolder_form_field_config_edit_form_alter(&$form, \Drupal\Core\Form\FormStateInterface $form_state, $form_id) {
  // If this is a config form for a file-esque field using the Brandfolder
  // URI scheme, disable the file upload directory setting.
  $route_params = \Drupal::routeMatch()->getParameters();
  if ($field_config = $route_params->get('field_config', FALSE)) {
    if ($field_storage = $field_config->getFieldStorageDefinition()) {
      if ($field_storage->getSetting('uri_scheme') == 'bf') {
        $form['settings']['file_directory']['#default_value'] = '';
        $form['settings']['file_directory']['#access'] = FALSE;
      }
    }
  }
}

/**
 * Implements hook_theme().
 */
function brandfolder_theme() {
  return [
    'brandfolder_browser_widget' => [
      'render element' => 'element',
    ],
  ];
}

/**
 * Prepares variables for Brandfolder Browser widget templates.
 *
 * Default template: brandfolder-browser-widget.html.twig.
 *
 * @param array $variables
 *   An associative array containing:
 *   - element: A render element representing the Brandfolder Browser widget.
 */
function template_preprocess_brandfolder_browser_widget(&$variables) {
  $element = $variables['element'];

  $variables['attributes'] = ['class' => ['brandfolder-browser-widget', 'js-form-managed-file', 'form-managed-file', 'clearfix']];

  $variables['data'] = [];
  foreach (Element::children($element) as $child) {
    $variables['data'][$child] = $element[$child];
  }
}

/**
 * Given a Brandfolder asset ID, return a Drupal file ID.
 *
 * If no managed file yet exists in Drupal for the given asset, attempt to
 * create one.
 *
 * @param string|object $asset
 *   Unique Brandfolder asset ID, or an object representing a Brandfolder asset.
 *   Objects must include the asset ID and CDN URL.
 * @param bool $create_new_file
 *   If TRUE, and no Drupal file exists for the given asset, create a new Drupal
 *   file entity and link it to the asset.
 *
 * @return bool|int
 *   The file ID on success; FALSE on failure.
 *
 * @throws \GuzzleHttp\Exception\GuzzleException
 *
 * @todo Move to class.
 */
function brandfolder_map_asset_to_file($asset, $create_new_file = TRUE) {
  $fid = FALSE;

  $logger = \Drupal::logger('brandfolder');

  $asset_id = is_string($asset) ? $asset : $asset->id;

  $db = \Drupal::database();
  $query = $db->select('brandfolder_file', 'bf')
    ->fields('bf', ['fid'])
    ->condition('bf_asset_id', $asset_id);
  if ($query->countQuery()->execute()->fetchField()) {
    $result = $query->execute();
    $fid = $result->fetch()->fid;
  }
  elseif ($create_new_file) {
    $bf = brandfolder_api();
    $params = [
      'fields' => 'cdn_url',
      'include' => 'attachments',
    ];
    if (is_string($asset)) {
      if ($asset = $bf->fetchAsset($asset_id, $params)) {
        $asset = $asset->data;
      }
    }
    if ($asset) {
      $file_data = [
        // Note: Start with 0 (temporary) file status, which will be changed to
        // 1 (permanent) by the File module if/when the host entity is saved.
        // File module will also create a file_usage record.
        // @todo: If the file is never made permanent, remove its brandfolder_file record? Or see if we can just jump straight to permanent status? That might run afoul of file/entity reference validation.
        'status' => 0,
        'uid' => \Drupal::currentUser()->id(),
      ];
      $bf_file_data = [
        'bf_asset_id' => $asset_id,
        'timestamp' => \Drupal::time()->getRequestTime(),
      ];
      $cdn_url = $asset->attributes->cdn_url;
      $info = brandfolder_parse_cdn_url($cdn_url);
      // @todo: Store CDN ID with each file/asset record or store once globally and assume it will not change? Or store once but update periodically?
      $bf_file_data['cdn_id'] = $info['cdn_id'];


      if (isset($asset->attachments)) {
        // Pull critical file data from the asset's first attachment.
        $primary_attachment = reset($asset->attachments);
        $filename = $primary_attachment->filename;
        $mime_type = $primary_attachment->mimetype;
        if (empty($mime_type)) {
          if (!$mime_type = brandfolder_get_mimetype_from_filename($filename)) {
            $logger->error('Attempting to map an asset to a Drupal file but this asset appears not to have a mimetype (asset ID !asset_id).', ['!asset_id' => $asset_id]);

            return FALSE;
          }
        }
        $file_data['filemime'] = $bf_file_data['mime_type'] = $mime_type;

        // Consider scenarios where this metadata is (temporarily) unavailable
        // due to delays in processing files for a recently created/updated
        // asset.
        if (is_null($primary_attachment->size) || is_null($primary_attachment->width) || is_null($primary_attachment->height)) {
          $logger->error('Attempting to map an asset to a Drupal file but this asset appears not to have the necessary file size data (asset ID !asset_id).', ['!asset_id' => $asset_id]);

          return FALSE;
        }
        $bf_file_data['filesize'] = $primary_attachment->size;
        $bf_file_data['width'] = $primary_attachment->width;
        $bf_file_data['height'] = $primary_attachment->height;
      }
      else {
        $logger->error('Attempting to map an asset to a Drupal file but this asset appears not to have any attachments (asset ID !asset_id).', ['!asset_id' => $asset_id]);

        return FALSE;
      }
      // The file extension in the CDN URL does not necessarily correspond to
      // the original file type. Use the latter in the URI so we can reliably
      // look up assets/Drupal files later based on URI.
      $uri = $info['uri'];
      if ($extension = brandfolder_image_mimetype_extension_mapping($primary_attachment->mimetype)) {
        $uri = preg_replace('/\.(\w+)$/', ".$extension", $uri);
        // If the attachment has a mime type but its filename has no extension,
        // add an appropriate extension to the Drupal file entity's filename.
        if (!preg_match('/\.\w+$/', $filename)) {
          $filename .= '.' . $extension;
        }
      }
      $file_data['filename'] = $filename;
      $file_data['uri'] = $bf_file_data['uri'] = $uri;

      // Store data in the brandfolder_file table before saving the file, so
      // we can use it to lookup things like filesize when the file is being
      // saved.
      $db->insert('brandfolder_file')
        ->fields($bf_file_data)
        ->execute();

      try {
        $file = File::Create($file_data);
        $file->save();
        $fid = $bf_file_data['fid'] = $file->id();

        // Update the brandfolder_file table with the newly created FID.
        $result = $db->merge('brandfolder_file')
          ->key([
            'uri'         => $uri,
            'bf_asset_id' => $asset_id,
          ])
          ->fields(['fid' => $fid])
          ->execute();
        if ($result != Database\Query\Merge::STATUS_UPDATE) {
          $logger->error('Could not find an existing record in the brandfolder_file table for asset ID !asset_id and file ID !fid.', [
            '!fid'      => $fid,
            '!asset_id' => $asset_id
          ]);
        }

        \Drupal::moduleHandler()->invokeAll('brandfolder_file_insert', [
          $file,
          $asset_id
        ]);
      }
      catch (\Drupal\Core\Entity\EntityStorageException $e) {
        $logger->error('There was an error saving a new file for Brandfolder asset !asset_id.', ['!asset_id' => $asset_id]);
      }
    }
  }

  return $fid;
}

/**
 * Helper function to parse a CDN URL and return useful derived data.
 *
 * @param string $cdn_url
 *   A full URL via which a Brandfolder asset is served on the Brandfolder CDN.
 *
 * @return array
 *   Array containing the following keys:
 *   ['uri', 'cdn_id', 'id', 'filename', 'type'].
 */
function brandfolder_parse_cdn_url($cdn_url) {
  $return = [
    'uri' => '',
    'cdn_id' => '',
    'id' => '',
    'filename' => '',
    'type' => '',
  ];

  if (preg_match("/.*cdn\.(brandfolder\.io|bfldr\.com)\/(([^\/]+)\/(as|at)\/([\w\-]+)\/(.*))/", $cdn_url, $matches)) {
    $uri_suffix = $matches[2];
    $return = [
      'uri' => 'bf://' . $uri_suffix,
      'cdn_id' => $matches[3],
      'id' => $matches[5],
      'filename' => $matches[6],
    ];
    $return['type'] = ($matches[4] == 'as') ? 'asset' : 'attachment';
  }

  return $return;
}

/**
 * Given a Drupal file ID, return a corresponding Brandfolder asset ID.
 *
 * If the file does not correspond to a Brandfolder asset, return FALSE.
 *
 * @param int $fid
 *   Drupal managed file ID.
 *
 * @return bool|string
 *   The asset ID on success; FALSE on failure.
 */
function brandfolder_map_file_id_to_asset($fid) {
  $asset_id = FALSE;

  $db = \Drupal::database();
  $query = $db->select('brandfolder_file', 'bf')
    ->fields('bf', ['bf_asset_id'])
    ->condition('fid', $fid);
  if ($query->countQuery()->execute()->fetchField()) {
    $result = $query->execute();
    $asset_id = $result->fetch()->bf_asset_id;
  }

  return $asset_id;
}

/**
 * Helper function to translate certain image mimetypes to file extensions.
 *
 * @param string $mimetype
 *   The file mime type (e.g. "image/jpeg").
 *
 * @return bool|string
 *   The file extension (e.g. "jpg") on success; FALSE if the given mime type
 *   cannot be mapped to an extension.
 */
function brandfolder_image_mimetype_extension_mapping($mimetype) {
  $extension = FALSE;

  $mime_type_mapping = [
    'image/gif' => 'gif',
    'image/jpeg' => 'jpg',
    'image/png' => 'png',
    'image/svg+xml' => 'svg',
    'image/tiff' => 'tiff',
    'image/webp' => 'webp',
  ];
  if (isset($mime_type_mapping[$mimetype])) {
    $extension = $mime_type_mapping[$mimetype];
  }

  return $extension;
}

/**
 * Helper function to determine a mime type based on a given filename.
 *
 * @param string $filename
 *   The name of the file to examine.
 *
 * @return null|string
 *   The mime type (e.g. "image/jpeg") on success; FALSE if the given file name
 *   cannot be mapped to a mime type.
 */
function brandfolder_get_mimetype_from_filename($filename) {
  $mimetype = NULL;

  if (preg_match('/\.([^\.]+)$/', $filename, $matches)) {
    $extension = $matches[1];

    $mimetype = \GuzzleHttp\Psr7\mimetype_from_extension($extension);
  }

  return $mimetype;
}

/**
 * Implements hook_ENTITY_TYPE_insert().
 */
function brandfolder_media_type_insert(MediaTypeInterface $media_type) {
  // Do not alter configuration during config sync.
  if ($media_type->isSyncing()) {
    return;
  }
  // Create an image field on new BrandfolderImage-sourced media types.
  if ($media_type->getSource() instanceof BrandfolderImage) {
    $source = $media_type->getSource();
    $image_field_storage = FieldStorageConfig::loadByName('media', 'bf_image');
    if (!$image_field_storage) {
      $image_field_storage = $source->createImageFieldStorage();
      $image_field_storage->save();
    }

    $image_field = $source->createImageField($media_type);
    $image_field->save();
  }
}

/**
 * Implements hook_ENTITY_TYPE_presave().
 */
function brandfolder_media_presave(MediaInterface $media) {
  // Create an image field on new BrandfolderImage-sourced media types.
  $source = $media->getSource();
  if ($source instanceof BrandfolderImage) {
    $bf_asset_id = $source->getSourceFieldValue($media);
    if (!empty($bf_asset_id)) {
      // @todo: If changed. Dupe reconciliation, etc.
      if ($fid = brandfolder_map_asset_to_file($bf_asset_id)) {
        $file = File::load($fid);
        $image_file_data = [
          'target_id' => $fid,
        ];
        $image = Drupal::service('image.factory')->get($file->getFileUri());
        if ($image->isValid()) {
          $image_file_data['width'] = $image->getWidth();
          $image_file_data['height'] = $image->getHeight();
        }
        $bf = brandfolder_api();
        $params = [
          'include' => 'custom_fields',
        ];
        if ($asset = $bf->fetchAsset($bf_asset_id, $params)) {
          if (!empty($asset->data->custom_field_values['alt-text'])) {
            $image_file_data['alt'] = $asset->data->custom_field_values['alt-text'];
          }
        }
        $media->set('bf_image', $image_file_data);
      }
    }
  }
}
