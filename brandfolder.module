<?php

/**
 * @file
 * Contains brandfolder.module.
 */

use Drupal\brandfolder\Service\BrandfolderGatekeeper;
use Drupal\brandfolder\Plugin\media\Source\BrandfolderImage;
use Drupal\Core\Routing\RouteMatchInterface;
use Brandfolder\Brandfolder;
use Drupal\Core\Render\Element;
use Drupal\field\Entity\FieldStorageConfig;
use Drupal\file\Entity\File;
use Drupal\Core\Database;
use Drupal\media\MediaInterface;
use Drupal\media\MediaTypeInterface;
use Drupal\Core\Entity\EntityMalformedException;

/**
 * Brandfolder helper function. For use in procedural code. De-emphasize this
 * in favor of services, etc.
 *
 * Helper function to get a Brandfolder object that can be used to interact with
 * the Brandfolder API.
 *
 * @param string|null $api_key
 *   If provided, an API key to use when connecting to Brandfolder. If not
 *   provided, the default API key set in the module configuration will be used.
 *
 * @return bool|object
 *   A \Brandfolder\Brandfolder object for interacting with the Brandfolder SDK,
 *   or FALSE on failure.
 */
function brandfolder_api(string $api_key = NULL) {
  // Get the default API key from module configuration if none is explicitly
  // provided.
  if (is_null($api_key)) {
    $api_key = \Drupal::config('brandfolder.settings')->get('api_key');
  }
  if (empty($api_key)) {
    return FALSE;
  }

  // Set Brandfolder and collection based on module config if present (NULL
  // otherwise).
  $default_brandfolder = \Drupal::config('brandfolder.settings')->get('default_brandfolder');
  $bf = new Brandfolder($api_key, $default_brandfolder);

  $default_collection = \Drupal::config('brandfolder.settings')->get('default_collection');
  if ($default_collection) {
    // @todo: getter/setter methods.
    $bf->default_collection_id = $default_collection;
  }

  return $bf;
}

/**
 * Implements hook_help().
 */
function brandfolder_help($route_name, RouteMatchInterface $route_match) {
  switch ($route_name) {
    // Main module help for the Brandfolder module.
    case 'help.page.brandfolder':
      $output = '';
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('Allows Brandfolder assets to be used by Drupal\'s Media/image/file systems.') . '</p>';

      return $output;
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function brandfolder_form_field_config_edit_form_alter(&$form, \Drupal\Core\Form\FormStateInterface $form_state, $form_id) {
  // If this is a config form for a file-esque field using the Brandfolder
  // URI scheme, disable the file upload directory setting.
  $route_params = \Drupal::routeMatch()->getParameters();
  if ($field_config = $route_params->get('field_config', FALSE)) {
    if ($field_storage = $field_config->getFieldStorageDefinition()) {
      if ($field_storage->getSetting('uri_scheme') == 'bf') {
        $form['settings']['file_directory']['#default_value'] = '';
        $form['settings']['file_directory']['#access'] = FALSE;
      }
    }
  }
}

/**
 * Implements hook_theme().
 */
function brandfolder_theme() {
  return [
    'brandfolder_browser_widget' => [
      'render element' => 'element',
    ],
  ];
}

/**
 * Prepares variables for Brandfolder Browser widget templates.
 *
 * Default template: brandfolder-browser-widget.html.twig.
 *
 * @param array $variables
 *   An associative array containing:
 *   - element: A render element representing the Brandfolder Browser widget.
 */
function template_preprocess_brandfolder_browser_widget(&$variables) {
  $element = $variables['element'];

  $variables['attributes'] = ['class' => ['brandfolder-browser-widget', 'js-form-managed-file', 'form-managed-file', 'clearfix']];

  $variables['data'] = [];
  foreach (Element::children($element) as $child) {
    $variables['data'][$child] = $element[$child];
  }
}

/**
 * Given a Brandfolder attachment, return a Drupal file ID.
 *
 * If no managed file yet exists in Drupal for the given attachment, attempt to
 * create one.
 *
 * @param string|object $attachment
 *   Unique Brandfolder attachment ID, or an object representing a Brandfolder
 *   attachment. Objects must include the attachment ID, CDN URL, and parent
 *   asset ID.
 * @param bool $create_new_file
 *   If TRUE, and no Drupal file exists for the given attachment, create a new
 *   Drupal file entity and link it to the attachment.
 *
 * @return bool|int
 *   The file ID on success; FALSE on failure.
 *
 * @throws \GuzzleHttp\Exception\GuzzleException
 *
 * @todo Move to class.
 */
function brandfolder_map_attachment_to_file($attachment, $create_new_file = TRUE) {
  $fid = FALSE;

  $logger = \Drupal::logger('brandfolder');

  $attachment_id = is_string($attachment) ? $attachment : $attachment->id;

  $db = \Drupal::database();
  $query = $db->select('brandfolder_file', 'bf')
    ->fields('bf', ['fid'])
    ->condition('bf_attachment_id', $attachment_id);
  if ($query->countQuery()->execute()->fetchField()) {
    $result = $query->execute();
    $fid = $result->fetch()->fid;
  }
  elseif ($create_new_file) {
    $bf = brandfolder_api();
    $params = [
      'fields' => 'cdn_url',
      'include' => 'asset',
    ];
    if (is_string($attachment)) {
      if ($attachment = $bf->fetchAttachment($attachment_id, $params)) {
        $attachment = $attachment->data;
      }
    }
    if ($attachment) {
      if (!empty($attachment->relationships->asset)) {
        $asset_id = $attachment->relationships->asset->data->id;
      }
      else {
        $logger->error('Could not determine the asset for the attachment with ID !attachment_id', ['!attachment_id' => $attachment_id]);

        return FALSE;
      }
      $file_data = [
        // Note: Start with 0 (temporary) file status, which will be changed to
        // 1 (permanent) by the File module if/when the host entity is saved.
        // File module will also create a file_usage record.
        // @todo: If the file is never made permanent, remove its brandfolder_file record? Or see if we can just jump straight to permanent status? That might run afoul of file/entity reference validation.
        'status' => 0,
        'uid' => \Drupal::currentUser()->id(),
      ];
      $bf_file_data = [
        'bf_attachment_id' => $attachment_id,
        'bf_asset_id' => $asset_id,
        'timestamp' => \Drupal::time()->getRequestTime(),
      ];
      $cdn_url = $attachment->attributes->cdn_url;
      $info = brandfolder_parse_cdn_url($cdn_url);
      $bf_file_data['cdn_id'] = $info['cdn_id'];

      $filename = $attachment->attributes->filename;
      $mime_type = $attachment->attributes->mimetype;
      if (empty($mime_type)) {
        if (!$mime_type = brandfolder_get_mimetype_from_filename($filename)) {
          $logger->error('Attempting to map an attachment to a Drupal file but this attachment appears not to have a mimetype (attachment ID !attachment_id).', ['!attachment_id' => $attachment_id]);

          return FALSE;
        }
      }
      $file_data['filemime'] = $bf_file_data['mime_type'] = $mime_type;

      // Consider scenarios where this metadata is (temporarily) unavailable
      // due to delays in processing files for a recently created/updated
      // attachment.
      if (is_null($attachment->attributes->size) || is_null($attachment->attributes->width) || is_null($attachment->attributes->height)) {
        $logger->error('Attempting to map an attachment to a Drupal file but this attachment appears not to have the necessary file size data (attachment ID !attachment_id).', ['!attachment_id' => $attachment_id]);

        return FALSE;
      }
      $bf_file_data['filesize'] = $attachment->attributes->size;
      $bf_file_data['width'] = $attachment->attributes->width;
      $bf_file_data['height'] = $attachment->attributes->height;

      // The file extension in the CDN URL does not necessarily correspond to
      // the original file type. Use the latter in the URI so we can reliably
      // look up attachments/Drupal files later based on URI.
      // @todo: More testing with CDN v2.1 and various image formats, extensionless files, etc.
      $uri = $info['uri'];
      if ($extension = brandfolder_image_mimetype_extension_mapping($mime_type)) {
        $uri = preg_replace('/\.(\w+)$/', ".$extension", $uri);
        // If the attachment has a mime type but its filename has no extension,
        // add an appropriate extension to the Drupal file entity's filename.
        if (!preg_match('/\.\w+$/', $filename)) {
          $filename .= '.' . $extension;
        }
      }
      $file_data['filename'] = $filename;
      $file_data['uri'] = $bf_file_data['uri'] = $uri;

      // Store data in the brandfolder_file table before saving the file, so
      // we can use it to lookup things like filesize when the file is being
      // saved.
      $db->insert('brandfolder_file')
        ->fields($bf_file_data)
        ->execute();

      try {
        $file = File::Create($file_data);
        $file->save();
        $fid = $bf_file_data['fid'] = $file->id();

        // Update the brandfolder_file table with the newly created FID.
        $result = $db->merge('brandfolder_file')
          ->key([
            'uri'         => $uri,
            'bf_attachment_id' => $attachment_id,
            'bf_asset_id' => $asset_id,
          ])
          ->fields(['fid' => $fid])
          ->execute();
        if ($result != Database\Query\Merge::STATUS_UPDATE) {
          $logger->error('Could not find an existing record in the brandfolder_file table for attachment ID !attachment_id and file ID !fid.', [
            '!fid'      => $fid,
            '!attachment_id' => $attachment_id
          ]);
        }

        \Drupal::moduleHandler()->invokeAll('brandfolder_file_insert', [
          $file,
          $attachment_id
        ]);
      }
      catch (\Drupal\Core\Entity\EntityStorageException $e) {
        $logger->error('There was an error saving a new file for Brandfolder attachment !attachment_id.', ['!attachment_id' => $attachment_id]);
      }
    }
  }

  return $fid;
}

/**
 * Helper function to map an attachment ID to an asset ID, prioritizing our
 * local registry (which is updated on asset.update webhook events).
 *
 * @param string $attachment_id
 *
 * @return string|bool
 */
function brandfolder_get_asset_from_attachment(string $attachment_id) {
  $asset_id = FALSE;

  $db = \Drupal::database();
  $query = $db->select('brandfolder_file', 'bf')
    ->fields('bf', ['bf_asset_id'])
    ->condition('bf_attachment_id', $attachment_id);
  if ($query->countQuery()->execute()->fetchField()) {
    $result = $query->execute();
    $asset_id = $result->fetch()->bf_asset_id;
  }

  return $asset_id;
}

/**
 * Helper function to parse a CDN URL and return useful derived data.
 *
 * @param string $cdn_url
 *   A full URL via which a Brandfolder attachment is served on the Brandfolder CDN.
 *
 * @return array
 *   Array containing the following keys:
 *   ['uri', 'cdn_id', 'id', 'filename', 'type'].
 */
function brandfolder_parse_cdn_url($cdn_url) {
  $return = [
    'uri' => '',
    'cdn_id' => '',
    'id' => '',
    'filename' => '',
    'type' => '',
  ];

  if (preg_match("/.*cdn\.(brandfolder\.io|bfldr\.com)\/(([^\/]+)\/(as|at)\/([\w\-]+)\/(.*))/", $cdn_url, $matches)) {
    $uri_suffix = $matches[2];
    $return = [
      'uri' => 'bf://' . $uri_suffix,
      'cdn_id' => $matches[3],
      'id' => $matches[5],
      'filename' => $matches[6],
    ];
    $return['type'] = ($matches[4] == 'as') ? 'asset' : 'attachment';
  }

  return $return;
}

/**
 * Given a Drupal file ID, return a corresponding Brandfolder attachment ID.
 *
 * If the file does not correspond to a Brandfolder attachment, return FALSE.
 *
 * @param int $fid
 *   Drupal managed file ID.
 *
 * @return bool|string
 *   The attachment ID on success; FALSE on failure.
 */
function brandfolder_map_file_id_to_attachment($fid) {
  $attachment_id = FALSE;

  $db = \Drupal::database();
  $query = $db->select('brandfolder_file', 'bf')
    ->fields('bf', ['bf_attachment_id'])
    ->condition('fid', $fid);
  if ($query->countQuery()->execute()->fetchField()) {
    $result = $query->execute();
    $attachment_id = $result->fetch()->bf_attachment_id;
  }

  return $attachment_id;
}

/**
 * Helper function to translate certain image mimetypes to file extensions.
 *
 * @param string $mimetype
 *   The file mime type (e.g. "image/jpeg").
 *
 * @return bool|string
 *   The file extension (e.g. "jpg") on success; FALSE if the given mime type
 *   cannot be mapped to an extension.
 */
function brandfolder_image_mimetype_extension_mapping($mimetype) {
  $extension = FALSE;

  $mime_type_mapping = [
    'image/gif' => 'gif',
    'image/jpeg' => 'jpg',
    'image/png' => 'png',
    'image/svg+xml' => 'svg',
    'image/tiff' => 'tiff',
    'image/webp' => 'webp',
  ];
  if (isset($mime_type_mapping[$mimetype])) {
    $extension = $mime_type_mapping[$mimetype];
  }

  return $extension;
}

/**
 * Helper function to determine a mime type based on a given filename.
 *
 * @param string $filename
 *   The name of the file to examine.
 *
 * @return null|string
 *   The mime type (e.g. "image/jpeg") on success; FALSE if the given file name
 *   cannot be mapped to a mime type.
 */
function brandfolder_get_mimetype_from_filename($filename) {
  $mimetype = NULL;

  if (preg_match('/\.([^\.]+)$/', $filename, $matches)) {
    $extension = $matches[1];

    $mimetype = \GuzzleHttp\Psr7\mimetype_from_extension($extension);
  }

  return $mimetype;
}

/**
 * Implements hook_ENTITY_TYPE_insert().
 */
function brandfolder_media_type_insert(MediaTypeInterface $media_type) {
  // Do not alter configuration during config sync.
  // @todo
  if ($media_type->isSyncing()) {
    return;
  }
  // Create an image field on new BrandfolderImage-sourced media types.
  if ($media_type->getSource() instanceof BrandfolderImage) {
    $source = $media_type->getSource();
    $image_field_storage = FieldStorageConfig::loadByName('media', 'bf_image');
    if (!$image_field_storage) {
      $image_field_storage = $source->createImageFieldStorage();
      $image_field_storage->save();
    }

    $image_field = $source->createImageField($media_type);
    $image_field->save();
  }
}

/**
 * Implements hook_ENTITY_TYPE_presave().
 *
 * @throws EntityMalformedException
 */
function brandfolder_media_presave(MediaInterface $media) {
  $source = $media->getSource();
  if ($source instanceof BrandfolderImage) {
    $logger = \Drupal::logger('brandfolder');
    $bf_attachment_id = $source->getSourceFieldValue($media);
    $bf_asset_id = brandfolder_get_asset_from_attachment($bf_attachment_id);
    if (!$bf_asset_id) {
      $msg = 'Could not map attachment ID !attachment_id to an asset.';
      $msg_vars = ['!attachment_id' => $bf_attachment_id];
      $logger->error($msg, $msg_vars);
      throw new EntityMalformedException(t($msg, $msg_vars));
    }
    // Create an image field on BrandfolderImage-sourced media types if one does
    // not already exist.
    if (empty($media->get('bf_image')->getValue())) {
      if (!empty($bf_attachment_id)) {
        // @todo: If changed. Dupe reconciliation, etc.
        if ($fid = brandfolder_map_attachment_to_file($bf_attachment_id)) {
          $file = File::load($fid);
          $image_file_data = [
            'target_id' => $fid,
          ];
          $image = Drupal::service('image.factory')->get($file->getFileUri());
          if ($image->isValid()) {
            $image_file_data['width'] = $image->getWidth();
            $image_file_data['height'] = $image->getHeight();
          }
          // @todo: Update per new SDK.
          if ($bf_asset_id = brandfolder_get_asset_from_attachment($bf_attachment_id)) {
            $bf = brandfolder_api();
            $params = [
              'include' => 'custom_fields',
            ];
            if ($asset = $bf->fetchAsset($bf_asset_id, $params)) {
              if (!empty($asset->data->custom_field_values['alt-text'])) {
                // @todo: asset.update webhook action to update this value if it is populated in BF in the future and the Drupal field remains empty.
                $image_file_data['alt'] = $asset->data->custom_field_values['alt-text'];
              }
            }
          }
          $media->set('bf_image', $image_file_data);
        }
      }
    }

    // Enforce Brandfolder configuration defined at the media type level.
    // Any violations will typically be caught elsewhere in a more user-friendly
    // fashion (e.g. on media entity create/edit form), but we check here to
    // ensure nothing falls through the cracks during programmatic entity
    // updates, etc.
    $gatekeeper = \Drupal::getContainer()
      ->get(BrandfolderGatekeeper::class);
    $gatekeeper->loadFromMediaSource($source);
    $valid = $gatekeeper->validateBrandfolderEntities(['attachments' => [$bf_attachment_id]]);
    if (!$valid) {
      $msg = $gatekeeper->getMessage();
      $logger->error($msg);
      throw new EntityMalformedException($msg);
    }
  }
}
