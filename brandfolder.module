<?php

/**
 * @file
 * Contains brandfolder.module.
 */

use Drupal\brandfolder\Service\BrandfolderGatekeeper;
use Drupal\brandfolder\Plugin\media\Source\BrandfolderImage;
use Drupal\Component\Utility\Html;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Routing\RouteMatchInterface;
use Brandfolder\Brandfolder;
use Drupal\Core\Render\Element;
use Drupal\Core\Url;
use Drupal\field\Entity\FieldStorageConfig;
use Drupal\file\Entity\File;
use Drupal\Core\Database;
use Drupal\media\Entity\Media;
use Drupal\media\MediaInterface;
use Drupal\media\MediaTypeInterface;
use Drupal\Core\Entity\EntityMalformedException;
use Drupal\media_library\MediaLibraryState;
use Drupal\views\ViewExecutable;
use Drupal\Core\Form\FormBuilderInterface;

/**
 * Brandfolder helper function. For use in procedural code. De-emphasize this
 * in favor of services, etc.
 *
 * Helper function to get a Brandfolder object that can be used to interact with
 * the Brandfolder API.
 *
 * @param string|null $api_key
 *   If provided, an API key to use when connecting to Brandfolder. If not
 *   provided, the default API key set in the module configuration will be used.
 *
 * @return bool|object
 *   A \Brandfolder\Brandfolder object for interacting with the Brandfolder SDK,
 *   or FALSE on failure.
 */
function brandfolder_api(string $api_key = NULL) {
  // Get the default API key from module configuration if none is explicitly
  // provided.
  if (is_null($api_key)) {
    $api_key = \Drupal::config('brandfolder.settings')->get('api_key');
  }
  if (empty($api_key)) {
    return FALSE;
  }

  // Set Brandfolder and collection based on module config if present (NULL
  // otherwise).
  $default_brandfolder = \Drupal::config('brandfolder.settings')->get('default_brandfolder');
  $bf = new Brandfolder($api_key, $default_brandfolder);

  $default_collection = \Drupal::config('brandfolder.settings')->get('default_collection');
  if ($default_collection) {
    // @todo: getter/setter methods.
    $bf->default_collection_id = $default_collection;
  }

  return $bf;
}

/**
 * Implements hook_help().
 */
function brandfolder_help($route_name, RouteMatchInterface $route_match) {
  switch ($route_name) {
    // Main module help for the Brandfolder module.
    case 'help.page.brandfolder':
      $output = '';
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('Allows Brandfolder assets to be used by Drupal\'s Media/image/file systems.') . '</p>';

      return $output;
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function brandfolder_form_field_config_edit_form_alter(&$form, \Drupal\Core\Form\FormStateInterface $form_state, $form_id) {
  // If this is a config form for a file-esque field using the Brandfolder
  // URI scheme, disable the file upload directory setting.
  $route_params = \Drupal::routeMatch()->getParameters();
  if ($field_config = $route_params->get('field_config', FALSE)) {
    if ($field_storage = $field_config->getFieldStorageDefinition()) {
      if ($field_storage->getSetting('uri_scheme') == 'bf') {
        $form['settings']['file_directory']['#default_value'] = '';
        $form['settings']['file_directory']['#access'] = FALSE;
      }
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function brandfolder_form_views_exposed_form_alter(&$form, \Drupal\Core\Form\FormStateInterface $form_state, $form_id) {
  // If this is a Views exposed filters form for a Media Library view pertaining
  // to a Brandfolder-sourced media type, disable it in favor of our own
  // browsing experience.
  // @todo: Review.
  $storage = $form_state->getStorage();
  if (isset($storage['view'])) {
    $view = $storage['view'];
    if ($view->storage->id() == 'media_library') {
      if (isset($view->args[0])) {
        $media_type_id = $view->args[0];
        $media_type = \Drupal::entityTypeManager()->getStorage('media_type')->load($media_type_id);
        if ($media_type && $media_type->getSource() instanceof BrandfolderImage) {
          $form = [];
        }
      }
    }
  }
}

/**
 * Implements hook_form_alter().
 */
function brandfolder_form_alter(&$form, \Drupal\Core\Form\FormStateInterface $form_state, $form_id) {
  // If this is a form comprising the main media entity listing in a Media
  // Library context, for a Brandfolder-sourced media type, replace the
  // user-facing form elements with our own browsing experience.
  if (preg_match('/^views_form_media_library_widget_(.+)$/', $form_id, $matches)) {
    $media_type_id = $matches[1];
    $media_type = \Drupal::entityTypeManager()->getStorage('media_type')->load($media_type_id);
    if ($media_type && $media_type->getSource() instanceof BrandfolderImage) {
      brandfolder_browser_media_library_form_manipulator($form, $form_state, $media_type);
    }
  }
  // Media entity edit forms for Brandfolder-sourced media.
  elseif (preg_match('/^media_(.+)_edit_form$/', $form_id, $matches)) {
    $media_type_id = $matches[1];
    $media_type = \Drupal::entityTypeManager()->getStorage('media_type')->load($media_type_id);
    if ($media_type && $media_type->getSource() instanceof BrandfolderImage) {
      // Make the all-important source field (BF attachment ID text field)
      // read-only.
      if (isset($form['field_brandfolder_attachment_id'])) {
        $form['field_brandfolder_attachment_id']['#disabled'] = TRUE;
      }
      // Disable the auto-managed BF Image field.
      // @todo: Make this field only minimally editable
      // (allow users to specify things like custom alt text but not
      // replace/remove the image itself).
      if (isset($form['bf_image'])) {
        $form['bf_image']['#disabled'] = TRUE;
      }
    }
  }
//  elseif ($form_id == 'field_config_edit_form') {
    // @todo: consider working around this core bug: https://www.drupal.org/project/drupal/issues/2833650.
    // Simply remove the default value selection option until the entity
    // reference field has been configured with allowed types.
    // This is outside the scope of the Brandfolder module, however.
//    unset($form['default_value']);
//  }
}

/**
 * Implements hook_views_pre_render().
 */
function brandfolder_views_pre_render(ViewExecutable $view) {
  // If this is a Media Library view pertaining to a Brandfolder-sourced media
  // type, remove view header and footer, as they are not part of our custom
  // browsing experience.
  if ($view->storage->id() == 'media_library') {
    if (isset($view->args[0])) {
      $media_type_id = $view->args[0];
      $media_type = \Drupal::entityTypeManager()
        ->getStorage('media_type')
        ->load($media_type_id);
      if ($media_type && $media_type->getSource() instanceof BrandfolderImage) {
        $view->header = $view->footer = [];
      }
    }
  }
}

/**
 * Procedural method to construct basic BF browser in a Media Library context.
 *
 * @param $form
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 * @param \Drupal\media\Entity\MediaType $media_type
 *
 * @todo: Replace with more elegant and feature-rich browser construct.
 */
function brandfolder_browser_media_library_form_manipulator(&$form, \Drupal\Core\Form\FormStateInterface $form_state, \Drupal\media\Entity\MediaType $media_type) {
  $media_source = $media_type->getSource();
  $gatekeeper = \Drupal::getContainer()
    ->get(BrandfolderGatekeeper::class);
  $gatekeeper->loadFromMediaSource($media_source);

  $selected_media_entity_ids = [];
  $selection_limit = -1;
  $build_info = $form_state->getBuildInfo();
  if ($build_info['base_form_id'] == 'views_form_media_library_widget' && isset($build_info['args'][0]) && $build_info['args'][0] instanceof \Drupal\views\ViewExecutable) {
    $view = $build_info['args'][0];
    if (strpos($view->current_display, 'widget') === 0) {
      try {
        $state = MediaLibraryState::fromRequest($view->getRequest());
//        $selections_remaining = $state->getAvailableSlots();
        $ml_opener_params = $state->getOpenerParameters();

        $field_manager = \Drupal::service('entity_field.manager');
        (array) $bundle_fields = $field_manager->getFieldDefinitions($ml_opener_params['entity_type_id'], $ml_opener_params['bundle']);
        $field_name = $ml_opener_params['field_name'];
        if (isset($bundle_fields[$field_name])) {
          $selection_limit = $bundle_fields[$field_name]->getFieldStorageDefinition()->getCardinality();
        }

        $user_input = $form_state->getUserInput();
        if (!empty($user_input[$field_name]['selection'])) {
          $selected_media_entity_ids = array_map(function($input) {
            return $input['target_id'];
          }, $user_input[$field_name]['selection']);
        }

      } catch (Exception $e) {}
    }
  }

  // Reduce selection limit by the number of already-selected entities, if
  // applicable.
  if ($selection_limit > 0) {
    $selection_limit -= count($selected_media_entity_ids);
    // Ensure we don't inadvertently push the limit below zero.
    $selection_limit = max($selection_limit, 0);
  }

  $selected_bf_attachment_ids = array_map('brandfolder_map_media_entity_to_attachment', $selected_media_entity_ids);
  $selected_bf_attachment_ids = array_filter($selected_bf_attachment_ids);

  brandfolder_browser($form, $gatekeeper, $selected_bf_attachment_ids, [], $selection_limit);

  // Relocate the BF browser element, using it to replace the standard Media
  // Library output entirely.
  $main_bf_browser_element = $form['brandfolder_browser'];
  unset($form['brandfolder_browser']);
  $form['output'] = [
    'brandfolder_browser' => $main_bf_browser_element
  ];
}

/**
 * Basic, agnostic function to embellish a form with elements needed for the
 * core BF browsing experience.
 *
 * @param $form
 * @param \Drupal\brandfolder\Service\BrandfolderGatekeeper $gatekeeper
 * @param array $disabled_attachment_ids
 * @param array $selected_attachment_ids
 * @param int $selection_limit
 *  This should be -1 if there is no limit.
 *
 * @todo: Relocate and make pluggable. See also brandfolder_browser_controls().
 */
function brandfolder_browser(&$form, BrandfolderGatekeeper $gatekeeper, array $disabled_attachment_ids = [], array $selected_attachment_ids = [], int $selection_limit = -1) {
  $bf_asset_list = t('No Brandfolder assets found.');
  $query_params = [
    'include' => 'attachments'
  ];
  // @todo: Pagination.
  $assets = $gatekeeper->fetchAssets($query_params);
  if ($assets && !empty($assets->data)) {
    $bf_asset_list = brandfolder_format_asset_list($assets, $disabled_attachment_ids, $selected_attachment_ids);
  }

  $browser_id = Html::getUniqueId('brandfolder-browser');
  $asset_container_id = brandfolder_browser_get_asset_list_container_id($form);

  $form['brandfolder_browser'] = [
    '#type' => 'fieldset',
    '#collabsible' => FALSE,
    '#prefix' => "<div id=\"$browser_id\" class=\"brandfolder-browser\" data-selection-limit=\"{$selection_limit}\">",
    '#suffix' => "</div>",
  ];
  $form['brandfolder_browser']['brandfolder_browser_controls'] = [
    '#type' => 'fieldset',
    '#collabsible' => FALSE,
    '#attributes' => [
      'class' => [
        'brandfolder-browser-controls',
      ],
    ],
  ];
  $controls = brandfolder_browser_controls($gatekeeper, $asset_container_id, $form['#form_id']);
  $form['brandfolder_browser']['brandfolder_browser_controls'] += $controls;

  $form['brandfolder_browser']['brandfolder_browser_assets'] = [
    '#markup' => "<div id=\"$asset_container_id\" class=\"brandfolder-assets\">
                    $bf_asset_list
                  </div>",
  ];

  $form['brandfolder_browser']['bf_gatekeeper_criteria'] = [
    '#type' => 'hidden',
    '#value' => json_encode($gatekeeper->getCriteria()),
  ];

  $form['disabled_bf_attachment_ids'] = [
    '#type' => 'hidden',
    '#attributes' => [
      'class' => 'disabled-bf-attachment-ids',
    ],
    '#default_value' => implode(',', $disabled_attachment_ids),
  ];

  $form['selected_bf_attachment_ids'] = [
    '#type' => 'hidden',
    '#attributes' => [
      'class' => 'selected-bf-attachment-ids',
    ],
    '#default_value' => implode(',', $selected_attachment_ids),
  ];

  $form['#attached']['library'][] = 'brandfolder/brandfolder-browser';
  $validation_handlers = !empty($form['#validate']) ? $form['#validate'] : [];
  array_unshift($validation_handlers, 'brandfolder_browser_selection_converter');
  $validation_handlers[] = 'brandfolder_browser_host_form_validator';
  $form['#validate'] = $validation_handlers;
}

/**
 * Helper function to get an ID for the asset list container element in a
 * Brandfolder browser.
 *
 * @param array $form
 *
 * @return string
 */
function brandfolder_browser_get_asset_list_container_id(array $form): string {
  $asset_container_id = $form['#form_id'] . '__brandfolder-browser-assets';

  // @todo: Use unique ID to avoid potential conflicts with multiple BF-related elements in a single form. The code below is a start, but needs to be fixed to avoid issues with AJAX rebuilds resulting in ID mismatches.
//  $asset_container_id_base = 'brandfolder-assets';
//
//  // If we're in an AJAX context where the async request was triggered by the
//  // Brandfolder browser with the intent to update an asset list, make sure to
//  // preserve the existing ID for the asset list container.
//  if (!is_null($form_state) && \Drupal::request()->isXmlHttpRequest()) {
//    if ($triggering_element = $form_state->getTriggeringElement()) {
//      if (isset($triggering_element['#ajax']['wrapper'])) {
//        $target_el_id = $triggering_element['#ajax']['wrapper'];
//        if (strpos($target_el_id, $asset_container_id_base) === 0) {
//          $asset_container_id = $target_el_id;
//        }
//      }
//    }
//  }
//  // Otherwise, generate a new unique element ID for the asset list container.
//  if (!isset($asset_container_id)) {
//    $asset_container_id = Html::getUniqueId($asset_container_id_base);
//  }

  return $asset_container_id;
}

/**
 * Helper function to convert an array of assets provided by the Brandfolder
 * API/SDK into an HTML list.
 *
 * @param object $assets
 * @param array $disabled_attachment_ids
 * @param array $selected_attachment_ids
 *
 * @return string
 *
 * @todo: Theme pattern, tpl, etc.
 */
function brandfolder_format_asset_list(object $assets, array $disabled_attachment_ids = [], array $selected_attachment_ids = []): string {
  $bf_asset_list_items = array_map(function ($asset) use ($disabled_attachment_ids, $selected_attachment_ids) {
    $output = '';
    if (!empty($asset->attachments)) {
      $output = "<li class=\"brandfolder-asset\" data-bf-asset-id=\"{$asset->id}\">"
        .         "<span class=\"brandfolder-asset__close_button\">&#8592;</span>"
        .         "<div class=\"brandfolder-asset__overview\">"
        .           "<h2 class=\"brandfolder-asset__heading\">{$asset->attributes->name}</h2>"
        .           "<figure>"
        .             "<img class=\"brandfolder-asset__thumb\" src=\"{$asset->attributes->thumbnail_url}\" />"
        .             "<figcaption class=\"brandfolder-asset__info\">"
        .               "<div class=\"bf-asset-metadata bf-asset-metadata--name\">{$asset->attributes->name}</div>"
        .               "<div class=\"bf-asset-metadata bf-asset-metadata--description\">{$asset->attributes->description}</div>"
        .             "</figcaption>"
        .           "</figure>"
        .          "</div>"
        .         "<div class=\"brandfolder-asset__attachments\">"
        .           "<h3 class=\"brandfolder-asset__attachment-list-heading\">" . t('Attachments') . "</h3>"
        .           "<ul class=\"brandfolder-asset__attachment-list\">";
      foreach ($asset->attachments as $attachment_id => $attachment) {
        $attachment_classes_array = ['brandfolder-attachment'];
        if (in_array($attachment_id, $disabled_attachment_ids)) {
          $attachment_classes_array[] = 'brandfolder-attachment--disabled';
        }
        if (in_array($attachment_id, $selected_attachment_ids)) {
          $attachment_classes_array[] = 'brandfolder-attachment--selected';
        }
        $attachment_classes = implode(' ', $attachment_classes_array);
        $output .= "<li class=\"$attachment_classes\" data-bf-attachment-id=\"{$attachment_id}\">"
          .     "<figure>"
          .       "<img class=\"brandfolder-attachment__image\" src=\"\" data-img-src=\"{$attachment->thumbnail_url}\" />"
          .       "<figcaption>"
          .         "<div class=\"bf-attachment-metadata\"><strong>" . t('Filename') . ":</strong> {$attachment->filename}</div>"
          .         "<div class=\"bf-attachment-metadata\"><strong>" . t('File Size') . ":</strong> " . format_size($attachment->size) . "</div>"
          .         "<div class=\"bf-attachment-metadata\"><strong>" . t('Dimensions') . ":</strong> {$attachment->width}x{$attachment->height}</div>"
          .       "</figcaption>"
          .     "</figure>"
          .   "</li>";
      }
      $output .= "</ul>"
        .     "</div>"
        .   "</li>";
    }

    return $output;
  }, $assets->data);

  $bf_asset_list = '<ul class="brandfolder-asset-list">' . implode(' ', $bf_asset_list_items) . '</ul>';

  return $bf_asset_list;
}

/**
 * Helper function to generate form elements to allow users to search for,
 * filter, sort, etc. assets in a Brandfolder browser context.
 *
 * @param \Drupal\brandfolder\Service\BrandfolderGatekeeper $gatekeeper
 * @param string $asset_container_id
 * @param $form_id
 *
 * @return array
 */
function brandfolder_browser_controls(BrandfolderGatekeeper $gatekeeper, string $asset_container_id, $form_id): array {
  $controls = [];

  // Explicitly set an AJAX URL to avoid problems with nested AJAX forms.
  // Any valid URL will work, but we use our dedicated stub route.
  // @todo Revisit depending on outcome of this core issue and related discussion: https://www.drupal.org/project/drupal/issues/2504115.
  $url = Url::fromRoute('brandfolder.asset_fetch_stub_route')->setOption('query', [FormBuilderInterface::AJAX_FORM_REQUEST => 1, 'form_id' => $form_id])->toString();

  $ajax_defaults = [
    'callback' => 'Drupal\brandfolder\Controller\AssetFetchController::assetFetchFormAjaxCallback',
    'wrapper' => $asset_container_id,
    'progress' => [
      'type' => 'throbber',
      'message' => t('Searching...'),
    ],
    'url' => $url,
  ];

  $attribute_defaults = [
    'class' => [
      'brandfolder-browser-control'
    ]
  ];

  $controls['search'] = [
    '#type' => 'fieldset',
    '#collapsible' => FALSE,
    '#attributes' => [
      'class' => [
        'brandfolder-browser-control-group',
        'brandfolder-browser-control-group--search',
      ],
    ],
  ];

  $controls['search']['brandfolder_controls_search_text'] = [
    '#type' => 'search',
    '#length' => 120,
    '#ajax' => $ajax_defaults,
    '#attributes' => $attribute_defaults,
  ];

  $controls['search']['brandfolder_controls_search_submit'] = [
    '#type' => 'button',
    '#value' => t('Search'),
    '#ajax' => $ajax_defaults,
    '#attributes' => $attribute_defaults,
    '#limit_validation_errors' => [],
  ];

  // Get all possible collections. If there are more than one, allow users to
  // filter by collection.
  $allowed_collections = $gatekeeper->getCollections();
  if (count($allowed_collections) > 1) {
    $controls['collections'] = [
      '#type' => 'fieldset',
      '#title' => t('Collections'),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
      '#attributes' => [
        'class' => [
          'brandfolder-browser-control-group',
          'brandfolder-browser-control-group--collections',
        ],
      ],
    ];
    foreach ($allowed_collections as $collection_id => $collection_name) {
      $controls['collections']["brandfolder_controls_collection_$collection_id"] = [
        '#type'       => 'checkbox',
        '#title'      => $collection_name,
        '#ajax'       => $ajax_defaults,
        '#attributes' => $attribute_defaults,
      ];
    }
  }

  // Get all possible sections. If there are more than one, allow users to
  // filter by section.
  $allowed_sections = $gatekeeper->getSections();
  if (count($allowed_sections) > 1) {
    $controls['sections'] = [
      '#type' => 'fieldset',
      '#title' => t('Sections'),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
      '#attributes' => [
        'class' => [
          'brandfolder-browser-control-group',
          'brandfolder-browser-control-group--sections',
        ],
      ],
    ];
    foreach ($allowed_sections as $section_id => $section_name) {
      $controls['sections']["brandfolder_controls_section_$section_id"] = [
        '#type'       => 'checkbox',
        '#title'      => $section_name,
        '#ajax'       => $ajax_defaults,
        '#attributes' => $attribute_defaults,
      ];
    }
  }
  
  // Get all possible labels. If there are more than one, allow users to
  // filter by label.
  $allowed_labels = $gatekeeper->getLabels();
  if (count($allowed_labels) > 1) {
    $controls['labels'] = [
      '#type'        => 'fieldset',
      //    '#title' => t('Labels'),
      '#collapsible' => TRUE,
      '#collapsed'   => TRUE,
      '#attributes'  => [
        'class' => [
          'brandfolder-browser-control-group',
          'brandfolder-browser-control-group--sections',
        ],
      ],
    ];
    $label_options = [];
    brandfolder_build_labels_select_list($allowed_labels, $label_options);
    $attributes = $attribute_defaults;
    $attributes['size'] = min(count($label_options), 10);
    $controls['labels']['brandfolder_controls_labels'] = [
      '#type' => 'select',
      '#title' => t('Labels'),
      '#attributes' => $attributes,
      '#ajax'       => $ajax_defaults,
      '#options' => $label_options,
      '#multiple' => TRUE,
    ];

  }

  $controls['sort'] = [
    '#type'        => 'fieldset',
    //    '#title' => t('Sort'),
    '#collapsible' => TRUE,
    '#collapsed'   => TRUE,
    '#attributes'  => [
      'class' => [
        'brandfolder-browser-control-group',
        'brandfolder-browser-control-group--sort',
      ],
    ],
  ];
  $controls['sort']['brandfolder_controls_sort_criterion'] = [
    '#title'         => t('Sort by'),
    '#type'          => 'select',
    '#options'       => [
      'name'       => t('Name'),
      'score'      => t('Score'),
      'position'   => t('Position'),
      'updated_at' => t('Updated'),
      'created_at' => t('Upload Date'),
    ],
    '#default_value' => 'created_at',
    '#ajax'          => $ajax_defaults,
    '#attributes'    => $attribute_defaults,
  ];
  $controls['sort']['brandfolder_controls_sort_order'] = [
    '#title'         => t('Sort Order'),
    '#type'          => 'select',
    '#options'       => [
      'asc'  => t('Ascending'),
      'desc' => t('Descending'),
    ],
    '#default_value' => 'desc',
    '#ajax'          => $ajax_defaults,
    '#attributes'    => $attribute_defaults,
  ];

  return $controls;
}

/**
 * Recursive function to generate nested select list from label tree.
 *
 * @param $labels
 * @param $select_options
 */
function brandfolder_build_labels_select_list($labels, &$select_options) {
  foreach ($labels as $id => $data) {
    $label = $data['label'];
    // Add this label to the list, indented according to depth.
    $display_value = '';
    $label_depth = $label->attributes->depth;
    if ($label_depth > 1) {
      for ($i = 1; $i < $label_depth; $i++) {
        $display_value .= '-';
      }
      $display_value .= ' ';
    }
    $display_value .= $label->attributes->name;
    $select_options[$label->id] = $display_value;

    // Recurse through any children/descendants.
    if (isset($data['children']) && is_array($data['children'])) {
      brandfolder_build_labels_select_list($data['children'], $select_options);
    }
  }
}

/**
 * Form validation handler to be applied to forms containing a Brandfolder 
 * Browser, after other validation handlers have executed.
 *
 * @param array $form
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *
 * @throws \GuzzleHttp\Exception\GuzzleException
 */
function brandfolder_browser_host_form_validator(array &$form, \Drupal\Core\Form\FormStateInterface &$form_state) {
  $triggering_element = $form_state->getTriggeringElement();
  // If the submission was triggered by one of our browser controls, the only
  // outcome should be to update the browser contents. We do not care about
  // other validation logic/errors.
  if (isset($triggering_element['#attributes']['class'])) {
    $classes = $triggering_element['#attributes']['class'];
    if (is_array($classes) && in_array('brandfolder-browser-control', $classes)) {
      $form_state->clearErrors();
    }
  }
}

/**
 * Helper function to translate Brandfolder browser selections to Drupal form
 * values. To be used as a form validation handler.
 *
 * @param array $form
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *
 * @throws \GuzzleHttp\Exception\GuzzleException
 */
function brandfolder_browser_selection_converter(array &$form, \Drupal\Core\Form\FormStateInterface &$form_state) {
  $triggering_element = $form_state->getTriggeringElement();
  // We don't need or want to perform validation when the submission is
  // triggered by one of our browser controls.
  if (isset($triggering_element['#attributes']['class'])) {
    $classes = $triggering_element['#attributes']['class'];
    if (is_array($classes) && in_array('brandfolder-browser-control', $classes)) {

      return;
    }
  }

  $selected_media_entities = [];
  $selected_media_entities_list = '';
  $selected_attachment_list = $form_state->getValue('selected_bf_attachment_ids');
  if (!empty($selected_attachment_list)) {
    $selected_attachments = explode(',', $selected_attachment_list);
    // Media Library context.
    if (preg_match('/^views_form_media_library_widget_(.+)$/', $form['#form_id'], $matches)) {
      $media_type_id = $matches[1];
      $selected_media_entities = array_map(function ($attachment_id) use ($media_type_id) {
        return brandfolder_map_attachment_to_media_entity($attachment_id, $media_type_id);
      }, $selected_attachments);
      $selected_media_entities_list = implode(',', $selected_media_entities);
    }
    // @todo: Other contexts.
  }
  $media_select_form_values = array_combine($selected_media_entities, $selected_media_entities);
  $form_state->setValue('media_library_select_form', $media_select_form_values);
  $form_state->setValue('media_library_select_form_selection', $selected_media_entities_list);
}

/**
 * Implements hook_theme().
 */
function brandfolder_theme() {
  return [
    'brandfolder_browser_widget' => [
      'render element' => 'element',
    ],
  ];
}

/**
 * Prepares variables for Brandfolder Browser widget templates.
 *
 * Default template: brandfolder-browser-widget.html.twig.
 *
 * @param array $variables
 *   An associative array containing:
 *   - element: A render element representing the Brandfolder Browser widget.
 */
function template_preprocess_brandfolder_browser_widget(&$variables) {
  $element = $variables['element'];

  $variables['attributes'] = ['class' => ['brandfolder-browser-widget', 'js-form-managed-file', 'form-managed-file', 'clearfix']];

  $variables['data'] = [];
  foreach (Element::children($element) as $child) {
    $variables['data'][$child] = $element[$child];
  }
}

/**
 * Given a Brandfolder attachment, return a Drupal file ID.
 *
 * If no managed file yet exists in Drupal for the given attachment, attempt to
 * create one.
 *
 * @param string|object $attachment
 *   Unique Brandfolder attachment ID, or an object representing a Brandfolder
 *   attachment. Objects must include the attachment ID, CDN URL, and parent
 *   asset ID.
 * @param bool $create_new_file
 *   If TRUE, and no Drupal file exists for the given attachment, create a new
 *   Drupal file entity and link it to the attachment.
 *
 * @return bool|int
 *   The file ID on success; FALSE on failure.
 *
 * @throws \GuzzleHttp\Exception\GuzzleException
 *
 * @todo Move to class.
 */
function brandfolder_map_attachment_to_file($attachment, $create_new_file = TRUE) {
  $fid = FALSE;

  $logger = \Drupal::logger('brandfolder');

  $attachment_id = is_string($attachment) ? $attachment : $attachment->id;

  $db = \Drupal::database();
  $query = $db->select('brandfolder_file', 'bf')
    ->fields('bf', ['fid'])
    ->condition('bf_attachment_id', $attachment_id);
  if ($query->countQuery()->execute()->fetchField()) {
    $result = $query->execute();
    $fid = $result->fetch()->fid;
  }
  elseif ($create_new_file) {
    $bf = brandfolder_api();
    $params = [
      'fields' => 'cdn_url',
      'include' => 'asset',
    ];
    if (is_string($attachment)) {
      if ($attachment = $bf->fetchAttachment($attachment_id, $params)) {
        $attachment = $attachment->data;
      }
    }
    if ($attachment) {
      if (!empty($attachment->relationships->asset)) {
        $asset_id = $attachment->relationships->asset->data->id;
      }
      else {
        $logger->error('Could not determine the asset for the attachment with ID !attachment_id', ['!attachment_id' => $attachment_id]);

        return FALSE;
      }
      $file_data = [
        // Note: Start with 0 (temporary) file status, which will be changed to
        // 1 (permanent) by the File module if/when the host entity is saved.
        // File module will also create a file_usage record.
        // @todo: If the file is never made permanent, remove its brandfolder_file record? Or see if we can just jump straight to permanent status? That might run afoul of file/entity reference validation.
        'status' => 0,
        'uid' => \Drupal::currentUser()->id(),
      ];
      $bf_file_data = [
        'bf_attachment_id' => $attachment_id,
        'bf_asset_id' => $asset_id,
        'timestamp' => \Drupal::time()->getRequestTime(),
      ];
      $cdn_url = $attachment->attributes->cdn_url;
      $info = brandfolder_parse_cdn_url($cdn_url);
      $bf_file_data['cdn_id'] = $info['cdn_id'];

      $filename = $attachment->attributes->filename;
      $mime_type = $attachment->attributes->mimetype;
      if (empty($mime_type)) {
        if (!$mime_type = brandfolder_get_mimetype_from_filename($filename)) {
          $logger->error('Attempting to map an attachment to a Drupal file but this attachment appears not to have a mimetype (attachment ID !attachment_id).', ['!attachment_id' => $attachment_id]);

          return FALSE;
        }
      }
      $file_data['filemime'] = $bf_file_data['mime_type'] = $mime_type;

      // Consider scenarios where this metadata is (temporarily) unavailable
      // due to delays in processing files for a recently created/updated
      // attachment.
      if (is_null($attachment->attributes->size) || is_null($attachment->attributes->width) || is_null($attachment->attributes->height)) {
        $logger->error('Attempting to map an attachment to a Drupal file but this attachment appears not to have the necessary file size data (attachment ID !attachment_id).', ['!attachment_id' => $attachment_id]);

        return FALSE;
      }
      $bf_file_data['filesize'] = $attachment->attributes->size;
      $bf_file_data['width'] = $attachment->attributes->width;
      $bf_file_data['height'] = $attachment->attributes->height;

      // The file extension in the CDN URL does not necessarily correspond to
      // the original file type. Use the latter in the URI so we can reliably
      // look up attachments/Drupal files later based on URI.
      // @todo: More testing with CDN v2.1 and various image formats, extensionless files, etc.
      $uri = $info['uri'];
      if ($extension = brandfolder_image_mimetype_extension_mapping($mime_type)) {
        $uri = preg_replace('/\.(\w+)$/', ".$extension", $uri);
        // If the attachment has a mime type but its filename has no extension,
        // add an appropriate extension to the Drupal file entity's filename.
        if (!preg_match('/\.\w+$/', $filename)) {
          $filename .= '.' . $extension;
        }
      }
      $file_data['filename'] = $filename;
      $file_data['uri'] = $bf_file_data['uri'] = $uri;

      // Store data in the brandfolder_file table before saving the file, so
      // we can use it to lookup things like filesize when the file is being
      // saved.
      $db->insert('brandfolder_file')
        ->fields($bf_file_data)
        ->execute();

      try {
        $file = File::Create($file_data);
        $file->save();
        $fid = $bf_file_data['fid'] = $file->id();

        // Update the brandfolder_file table with the newly created FID.
        $result = $db->merge('brandfolder_file')
          ->key([
            'uri'         => $uri,
            'bf_attachment_id' => $attachment_id,
            'bf_asset_id' => $asset_id,
          ])
          ->fields(['fid' => $fid])
          ->execute();
        if ($result != Database\Query\Merge::STATUS_UPDATE) {
          $logger->error('Could not find an existing record in the brandfolder_file table for attachment ID !attachment_id and file ID !fid.', [
            '!fid'      => $fid,
            '!attachment_id' => $attachment_id
          ]);
        }

        \Drupal::moduleHandler()->invokeAll('brandfolder_file_insert', [
          $file,
          $attachment_id
        ]);
      }
      catch (\Drupal\Core\Entity\EntityStorageException $e) {
        $logger->error('There was an error saving a new file for Brandfolder attachment !attachment_id.', ['!attachment_id' => $attachment_id]);
      }
    }
  }

  return $fid;
}

/**
 * Given a Brandfolder attachment, return a Drupal media entity ID.
 *
 * If no media entity yet exists for the given attachment, attempt to
 * create one.
 *
 * @param string|object $attachment
 *    Unique Brandfolder attachment ID, or an object representing a Brandfolder
 *    attachment.
 * @param bool $create_new_entity
 *    If TRUE, and no Drupal media entity exists for the given attachment,
 *    create a new media entity and link it to the attachment.
 *
 * @return bool|int
 *   The media entity ID on success; FALSE on failure.
 *
 * @throws \GuzzleHttp\Exception\GuzzleException
 *
 */
function brandfolder_map_attachment_to_media_entity($attachment, $media_type_id, $create_new_entity = TRUE) {
  $entity_id = FALSE;

  $logger = \Drupal::logger('brandfolder');

  $attachment_id = is_string($attachment) ? $attachment : $attachment->id;
  // @todo: Global constant, config, etc.?
  $bf_media_source_field_name = 'field_brandfolder_attachment_id';

  // Check to see if a media entity of the given type already exists for this
  // BF attachment.
  $results = \Drupal::entityQuery('media')
    ->condition('bundle', $media_type_id)
    ->condition($bf_media_source_field_name, $attachment_id)
    ->range(0, 1)
    ->execute();

  if (!empty($results)) {
    $entity_id = reset($results);
  }
  elseif ($create_new_entity) {
    if ($attachment_id) {
      try {
        // Generate a default name.
        // @todo: Improve on this by allowing admins to configure patterns for auto-created entity names?
        $default_name = "Auto-Created Entity for Brandfolder Attachment $attachment_id";
        $asset = FALSE;
        $bf_client = brandfolder_api();
        if ($attachment = $bf_client->fetchAttachment($attachment_id, ['include' => 'asset'])) {
          $asset_id = $attachment->data->relationships->asset->data->id ?? FALSE;
          if ($asset_id) {
            $asset = $bf_client->fetchAsset($asset_id);
          }
          $default_name = $asset ? "{$asset->data->attributes->name} - {$attachment->data->attributes->filename}" : $attachment->data->attributes->filename;
        }
        $media = Media::create([
          'name' => $default_name,
          'bundle' => $media_type_id,
          $bf_media_source_field_name => $attachment_id,
        ]);
        $media->save();
        $entity_id = $media->id();
      }
      catch (\Drupal\Core\Entity\EntityStorageException $e) {
        $logger->error('There was an error saving a new media entity for Brandfolder attachment !attachment_id.', ['!attachment_id' => $attachment_id]);
      }
    }
  }

  return $entity_id;
}

/**
 * Given a Drupal media entity ID, return a Brandfolder attachment ID.
 *
 * @param int $media_entity_id
 *
 * @return bool|string
 *   The attachment ID on success; FALSE on failure.
 */
function brandfolder_map_media_entity_to_attachment(int $media_entity_id) {
  $attachment_id = FALSE;
  if ($media = \Drupal::entityTypeManager()->getStorage('media')->load($media_entity_id)) {
    // @todo: Global constant, config, etc.?
    $bf_media_source_field_name = 'field_brandfolder_attachment_id';
    $field_item_list = $media->get($bf_media_source_field_name);
    if ($field_item_list->count() > 0) {
      $attachment_id = $field_item_list->first()->getValue()['value'];
    }
  }

  if (!$attachment_id) {
    $logger = \Drupal::logger('brandfolder');
    $logger->error('Could not determine a Brandfolder attachment ID for media entity ID !media_entity_id', ['!media_entity_id' => $media_entity_id]);
  }

  return $attachment_id;
}

/**
 * Helper function to map an attachment ID to an asset ID, prioritizing our
 * local registry (which is updated on asset.update webhook events).
 *
 * @param string $attachment_id
 *
 * @return string|bool
 */
function brandfolder_get_asset_from_attachment(string $attachment_id) {
  $asset_id = FALSE;

  $db = \Drupal::database();
  $query = $db->select('brandfolder_file', 'bf')
    ->fields('bf', ['bf_asset_id'])
    ->condition('bf_attachment_id', $attachment_id);
  if ($query->countQuery()->execute()->fetchField()) {
    $result = $query->execute();
    $asset_id = $result->fetch()->bf_asset_id;
  }

  return $asset_id;
}

/**
 * Helper function to parse a CDN URL and return useful derived data.
 *
 * @param string $cdn_url
 *   A full URL via which a Brandfolder attachment is served on the Brandfolder CDN.
 *
 * @return array
 *   Array containing the following keys:
 *   ['uri', 'cdn_id', 'id', 'filename', 'type'].
 */
function brandfolder_parse_cdn_url($cdn_url) {
  $return = [
    'uri' => '',
    'cdn_id' => '',
    'id' => '',
    'filename' => '',
    'type' => '',
  ];

  if (preg_match("/.*cdn\.(brandfolder\.io|bfldr\.com)\/(([^\/]+)\/(as|at)\/([\w\-]+)\/(.*))/", $cdn_url, $matches)) {
    $uri_suffix = $matches[2];
    $return = [
      'uri' => 'bf://' . $uri_suffix,
      'cdn_id' => $matches[3],
      'id' => $matches[5],
      'filename' => $matches[6],
    ];
    $return['type'] = ($matches[4] == 'as') ? 'asset' : 'attachment';
  }

  return $return;
}

/**
 * Given a Drupal file ID, return a corresponding Brandfolder attachment ID.
 *
 * If the file does not correspond to a Brandfolder attachment, return FALSE.
 *
 * @param int $fid
 *   Drupal managed file ID.
 *
 * @return bool|string
 *   The attachment ID on success; FALSE on failure.
 */
function brandfolder_map_file_id_to_attachment($fid) {
  $attachment_id = FALSE;

  $db = \Drupal::database();
  $query = $db->select('brandfolder_file', 'bf')
    ->fields('bf', ['bf_attachment_id'])
    ->condition('fid', $fid);
  if ($query->countQuery()->execute()->fetchField()) {
    $result = $query->execute();
    $attachment_id = $result->fetch()->bf_attachment_id;
  }

  return $attachment_id;
}

/**
 * Helper function to translate certain image mimetypes to file extensions.
 *
 * @param string $mimetype
 *   The file mime type (e.g. "image/jpeg").
 *
 * @return bool|string
 *   The file extension (e.g. "jpg") on success; FALSE if the given mime type
 *   cannot be mapped to an extension.
 */
function brandfolder_image_mimetype_extension_mapping($mimetype) {
  $extension = FALSE;

  $mime_type_mapping = [
    'image/gif' => 'gif',
    'image/jpeg' => 'jpg',
    'image/png' => 'png',
    'image/svg+xml' => 'svg',
    'image/tiff' => 'tiff',
    'image/webp' => 'webp',
  ];
  if (isset($mime_type_mapping[$mimetype])) {
    $extension = $mime_type_mapping[$mimetype];
  }

  return $extension;
}

/**
 * Helper function to determine a mime type based on a given filename.
 *
 * @param string $filename
 *   The name of the file to examine.
 *
 * @return null|string
 *   The mime type (e.g. "image/jpeg") on success; FALSE if the given file name
 *   cannot be mapped to a mime type.
 */
function brandfolder_get_mimetype_from_filename($filename) {
  $mimetype = NULL;

  if (preg_match('/\.([^\.]+)$/', $filename, $matches)) {
    $extension = $matches[1];

    $mimetype = \GuzzleHttp\Psr7\mimetype_from_extension($extension);
  }

  return $mimetype;
}

/**
 * Implements hook_ENTITY_TYPE_insert().
 */
function brandfolder_media_type_insert(MediaTypeInterface $media_type) {
  // Do not alter configuration during config sync.
  // @todo
  if ($media_type->isSyncing()) {
    return;
  }
  // Create an image field on new BrandfolderImage-sourced media types.
  if ($media_type->getSource() instanceof BrandfolderImage) {
    $source = $media_type->getSource();
    $image_field_storage = FieldStorageConfig::loadByName('media', 'bf_image');
    if (!$image_field_storage) {
      $image_field_storage = $source->createImageFieldStorage();
      $image_field_storage->save();
    }

    $image_field = $source->createImageField($media_type);
    $image_field->save();
  }
}

/**
 * Implements hook_ENTITY_TYPE_presave().
 *
 * @throws EntityMalformedException
 */
function brandfolder_media_presave(MediaInterface $media) {
  $source = $media->getSource();
  if ($source instanceof BrandfolderImage) {
    $logger = \Drupal::logger('brandfolder');
    $bf_attachment_id = $source->getSourceFieldValue($media);
    $bf_asset_id = brandfolder_get_asset_from_attachment($bf_attachment_id);
    if (!$bf_asset_id) {
      $msg = 'Could not map attachment ID @attachment_id to an asset.';
      $msg_vars = ['@attachment_id' => $bf_attachment_id];
      $logger->error($msg, $msg_vars);
      throw new EntityMalformedException(t($msg, $msg_vars));
    }
    // Create an image field on BrandfolderImage-sourced media types if one does
    // not already exist.
    if (empty($media->get('bf_image')->getValue())) {
      if (!empty($bf_attachment_id)) {
        // @todo: If changed. Dupe reconciliation, etc.
        if ($fid = brandfolder_map_attachment_to_file($bf_attachment_id)) {
          $file = File::load($fid);
          $image_file_data = [
            'target_id' => $fid,
          ];
          $image = Drupal::service('image.factory')->get($file->getFileUri());
          if ($image->isValid()) {
            $image_file_data['width'] = $image->getWidth();
            $image_file_data['height'] = $image->getHeight();
          }
          // @todo: Update per new SDK.
          if ($bf_asset_id = brandfolder_get_asset_from_attachment($bf_attachment_id)) {
            $bf = brandfolder_api();
            $params = [
              'include' => 'custom_fields',
            ];
            if ($asset = $bf->fetchAsset($bf_asset_id, $params)) {
              if (!empty($asset->data->custom_field_values['alt-text'])) {
                // @todo: asset.update webhook action to update this value if it is populated in BF in the future and the Drupal field remains empty.
                $image_file_data['alt'] = $asset->data->custom_field_values['alt-text'];
              }
            }
          }
          $media->set('bf_image', $image_file_data);
        }
      }
    }

    // Enforce Brandfolder configuration defined at the media type level.
    // Any violations will typically be caught elsewhere in a more user-friendly
    // fashion (e.g. on media entity create/edit form), but we check here to
    // ensure nothing falls through the cracks during programmatic entity
    // updates, etc.
    $gatekeeper = \Drupal::getContainer()
      ->get(BrandfolderGatekeeper::class);
    $gatekeeper->loadFromMediaSource($source);
    $valid = $gatekeeper->validateBrandfolderEntities(['attachments' => [$bf_attachment_id]]);
    if (!$valid) {
      $msg = $gatekeeper->getMessage();
      $logger->error($msg);
      throw new EntityMalformedException($msg);
    }
  }
}
