<?php

/**
 * @file
 * Contains brandfolder.module.
 */

use Drupal\brandfolder\Service\BrandfolderGatekeeper;
use Drupal\brandfolder\Plugin\media\Source\BrandfolderImage;
use Drupal\Component\Utility\Html;
use Drupal\Core\Entity\EntityStorageException;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Routing\RouteMatchInterface;
use Brandfolder\Brandfolder;
use Drupal\Core\Render\Element;
use Drupal\Core\Url;
use Drupal\field\Entity\FieldStorageConfig;
use Drupal\file\Entity\File;
use Drupal\Core\Database;
use Drupal\media\Entity\Media;
use Drupal\media\MediaInterface;
use Drupal\media\MediaTypeInterface;
use Drupal\Core\Entity\EntityMalformedException;
use Drupal\media_library\MediaLibraryState;
use Drupal\views\ViewExecutable;
use Drupal\Core\Form\FormBuilderInterface;

/**
 * Helper function for use in procedural code. De-emphasize this in favor of
 * services, etc.
 *
 * Get a Brandfolder object that can be used to interact with the
 * Brandfolder API.
 *
 * @param string|null $stored_key_type
 *  The type of key to use when retrieving an API key stored in module
 *  configuration. Options are 'admin', 'collaborator', and 'guest' (default).
 * @param string|null $custom_api_key
 *   If provided, an API key to use when connecting to Brandfolder. If not
 *   provided, an API key set in the module configuration will be used.
 *
 * @return Brandfolder|false
 *  A \Brandfolder\Brandfolder instance for interacting with the Brandfolder
 *  SDK, or FALSE on failure.
 */
function brandfolder_api(?string $stored_key_type = 'guest', string $custom_api_key = NULL) {
  $config = \Drupal::config('brandfolder.settings');

  $api_key_types = [
    'admin',
    'collaborator',
    'guest',
  ];
  if (in_array($stored_key_type, $api_key_types)) {
    $api_key = $config->get("api_keys.$stored_key_type");
  }
  elseif (!is_null($custom_api_key)) {
    $api_key = $custom_api_key;
  }
  if (empty($api_key)) {

    return FALSE;
  }

  // Set Brandfolder based on module config if present (NULL otherwise).
  $brandfolder_id = \Drupal::config('brandfolder.settings')->get('brandfolder_id');

  $bf = new Brandfolder($api_key, $brandfolder_id);

  if ($config->get('verbose_log_mode')) {
    $bf->enableVerboseLogging();
  }

  return $bf;
}

/**
 * Implements hook_help().
 */
function brandfolder_help($route_name, RouteMatchInterface $route_match) {
  $output = '';

  switch ($route_name) {
    // Main module help for the Brandfolder module.
    case 'help.page.brandfolder':
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('Allows Brandfolder assets to be used by Drupal\'s Media/image/file systems.') . '</p>';
  }

  return $output;
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function brandfolder_form_field_config_edit_form_alter(&$form, \Drupal\Core\Form\FormStateInterface $form_state, $form_id) {
  // If this is a config form for a file-esque field using the Brandfolder
  // URI scheme, disable the file upload directory setting.
  $route_params = \Drupal::routeMatch()->getParameters();
  if ($field_config = $route_params->get('field_config', FALSE)) {
    if ($field_storage = $field_config->getFieldStorageDefinition()) {
      if ($field_storage->getSetting('uri_scheme') == 'bf') {
        $form['settings']['file_directory']['#default_value'] = '';
        $form['settings']['file_directory']['#access'] = FALSE;
      }
    }
  }
}

/**
 * Implements hook_form_alter().
 */
function brandfolder_form_alter(&$form, \Drupal\Core\Form\FormStateInterface $form_state, $form_id) {
  // If this is a form comprising the main media entity listing in a Media
  // Library context, for a Brandfolder-sourced media type, replace the
  // user-facing form elements with our own browsing experience.
  if (preg_match('/^views_form_media_library_widget_(.+)$/', $form_id, $matches)) {
    $media_type_id = $matches[1];
    $media_type = \Drupal::entityTypeManager()->getStorage('media_type')->load($media_type_id);
    if ($media_type && $media_type->getSource() instanceof BrandfolderImage) {
      brandfolder_browser_media_library_form_manipulator($form, $form_state, $media_type);
    }
  }
  // Media entity edit forms for Brandfolder-sourced media.
  elseif (preg_match('/^media_(.+)_edit_form$/', $form_id, $matches)) {
    $media_type_id = $matches[1];
    $media_type = \Drupal::entityTypeManager()->getStorage('media_type')->load($media_type_id);
    if ($media_type && $media_type->getSource() instanceof BrandfolderImage) {
      // Make the all-important source field (BF attachment ID text field)
      // read-only.
      if (isset($form['field_brandfolder_attachment_id'])) {
        $form['field_brandfolder_attachment_id']['#disabled'] = TRUE;
      }
      // Limit users' ability to interact with the auto-managed BF Image field.
      // @see brandfolder_process_image_widget_for_internal_field().
      if (isset($form['bf_image']) && isset($form['bf_image']['widget'])) {
        $widget_deltas = Element::children($form['bf_image']['widget']);
        foreach ($widget_deltas as $delta) {
          $form['bf_image']['widget'][$delta]['#process'][] = 'brandfolder_process_image_widget_for_internal_field';
        }
      }
    }
  }
//  elseif ($form_id == 'field_config_edit_form') {
    // @todo: consider working around this core bug: https://www.drupal.org/project/drupal/issues/2833650.
    // Simply remove the default value selection option until the entity
    // reference field has been configured with allowed types.
    // This is outside the scope of the Brandfolder module, however.
//    unset($form['default_value']);
//  }
}

/**
 * Widget process callback for image widgets pertaining to special image field
 * that we auto-generate/populate based on linked Brandfolder attachment.
 *
 * @param $element
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 * @param $form
 *
 * @return array
 *
 * @see brandfolder_form_alter().
 */
function brandfolder_process_image_widget_for_internal_field($element, FormStateInterface $form_state, $form) {
  // Disable the main file manipulation elements while leaving supplemental
  // elements like alt text field accessible.
  $off_limits_items = [
    'upload_button',
    'remove_button',
    'upload',
  ];
  foreach ($off_limits_items as $key) {
    $element[$key]['#access'] = FALSE;
  }

  return $element;
}

/**
 * Implements hook_views_pre_render().
 */
function brandfolder_views_pre_render(ViewExecutable $view) {
  // If this is a Media Library view pertaining to a Brandfolder-sourced media
  // type, remove view header and footer, as they are not part of our custom
  // browsing experience.
  if ($view->storage->id() == 'media_library') {
    if (isset($view->args[0])) {
      $media_type_id = $view->args[0];
      $media_type = \Drupal::entityTypeManager()
        ->getStorage('media_type')
        ->load($media_type_id);
      if ($media_type && $media_type->getSource() instanceof BrandfolderImage) {
        $view->header = $view->footer = [];
      }
    }
  }
}

/**
 * Implements hook_views_pre_build().
 */
function brandfolder_views_pre_build(ViewExecutable $view) {
  // If this is a Media Library view pertaining to a Brandfolder-sourced media
  // type, remove view header and footer, as they are not part of our custom
  // browsing experience.
  if ($view->storage->id() == 'media_library') {
    if (isset($view->args[0])) {
      $media_type_id = $view->args[0];
      $media_type = \Drupal::entityTypeManager()
        ->getStorage('media_type')
        ->load($media_type_id);
      if ($media_type && $media_type->getSource() instanceof BrandfolderImage) {
        // Tell view not to use exposed form.
        $view->display_handler->has_exposed = FALSE;
      }
    }
  }
}

/**
 * Procedural method to construct basic BF browser in a Media Library context.
 *
 * @param $form
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 * @param \Drupal\media\Entity\MediaType $media_type
 *
 * @todo: Replace with more elegant and feature-rich browser construct.
 */
function brandfolder_browser_media_library_form_manipulator(&$form, \Drupal\Core\Form\FormStateInterface $form_state, \Drupal\media\Entity\MediaType $media_type) {
  $media_source = $media_type->getSource();
  $gatekeeper = \Drupal::getContainer()
    ->get(BrandfolderGatekeeper::class);
  $gatekeeper->loadFromMediaSource($media_source);

  $context = ['media_library'];
  $selected_media_entity_ids = [];
  $selection_limit = -1;
  $build_info = $form_state->getBuildInfo();
  if ($build_info['base_form_id'] == 'views_form_media_library_widget' && isset($build_info['args'][0]) && $build_info['args'][0] instanceof \Drupal\views\ViewExecutable) {
    $view = $build_info['args'][0];
    if (strpos($view->current_display, 'widget') === 0) {
      try {
        $state = MediaLibraryState::fromRequest($view->getRequest());
        $selection_limit = $state->getAvailableSlots();
        $ml_opener_params = $state->getOpenerParameters();

        $field_name = $ml_opener_params['field_name'];
        $context[] = $field_name;

        $user_input = $form_state->getUserInput();
        if (!empty($user_input[$field_name]['selection'])) {
          $selected_media_entity_ids = array_map(function($input) {
            return $input['target_id'];
          }, $user_input[$field_name]['selection']);
        }

      } catch (Exception $e) {}
    }
  }

  $selected_bf_attachment_ids = array_map('brandfolder_map_media_entity_to_attachment', $selected_media_entity_ids);
  $selected_bf_attachment_ids = array_filter($selected_bf_attachment_ids);

  $context_string = implode('-', $context);
  brandfolder_browser_init($form, $form_state, $gatekeeper, $selected_bf_attachment_ids, [], $selection_limit, $context_string);

  // Completely replace standard validation with our own custom
  // validators/processors.
  $form['#validate'] = [
    'brandfolder_browser_to_media_library_selection_converter',
    'brandfolder_browser_host_form_validator',
  ];

  // Relocate the BF browser element, using it to replace the standard Media
  // Library output entirely.
  $main_bf_browser_element = $form['brandfolder_browser'];
  unset($form['brandfolder_browser']);
  $form['output'] = [
    'brandfolder_browser' => $main_bf_browser_element
  ];
}

/**
 * Basic, agnostic function to embellish a form with elements needed for the
 * core BF browsing experience.
 *
 * @param array $form
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 * @param \Drupal\brandfolder\Service\BrandfolderGatekeeper $gatekeeper
 * @param array $disabled_attachment_ids
 * @param array $selected_attachment_ids
 * @param int $selection_limit
 *  This should be -1 if there is no limit.
 * @param string|null $context_id
 *
 * @todo: Relocate and make pluggable. See also brandfolder_browser_controls().
 */
function brandfolder_browser_init(&$form, FormStateInterface $form_state, BrandfolderGatekeeper $gatekeeper, array $disabled_attachment_ids = [], array $selected_attachment_ids = [], int $selection_limit = -1, string $context_id = NULL) {
  $bf_asset_list = t('No Brandfolder assets found.');
  $query_params = [
    'include' => 'attachments'
  ];
  // @todo: Pagination.
  $assets = $gatekeeper->fetchAssets($query_params);
  if ($assets && !empty($assets->data)) {
    $bf_asset_list = brandfolder_format_asset_list($assets, $disabled_attachment_ids, $selected_attachment_ids);
  }

  brandfolder_browser_core($form, $form_state, $gatekeeper, $bf_asset_list, $selection_limit, $context_id);

  $form['disabled_bf_attachment_ids'] = [
    '#type' => 'hidden',
    '#attributes' => [
      'class' => 'disabled-bf-attachment-ids',
    ],
    '#default_value' => implode(',', $disabled_attachment_ids),
  ];

  $form['selected_bf_attachment_ids'] = [
    '#type' => 'hidden',
    '#attributes' => [
      'class' => 'selected-bf-attachment-ids',
    ],
    '#default_value' => implode(',', $selected_attachment_ids),
  ];

  $form['#attached']['library'][] = 'brandfolder/brandfolder-browser';
}

/**
 * Basic, agnostic function to embellish a form with elements needed for the
 * core BF browsing experience.
 *
 * @param array $form
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 * @param \Drupal\brandfolder\Service\BrandfolderGatekeeper $gatekeeper
 * @param string $bf_asset_list
 * @param int $selection_limit
 *  This should be -1 if there is no limit.
 * @param string|null $context_id
 *
 * @todo: Relocate and make pluggable. See also brandfolder_browser_controls().
 */
function brandfolder_browser_core(array &$form, FormStateInterface $form_state, BrandfolderGatekeeper $gatekeeper, string $bf_asset_list, int $selection_limit = -1, string $context_id = NULL) {
  $bf_browser_id = $form_state->getValue('brandfolder_browser_id');
  if (empty($bf_browser_id)) {
    $all_input = $form_state->getUserInput();
    if (!empty($all_input['brandfolder_browser_id'])) {
      $bf_browser_id = $all_input['brandfolder_browser_id'];
    }
    else {
      $id_components = [
        'brandfolder-browser'
      ];
      if ($context_id) {
        $id_components[] = $context_id;
      }
      $bf_browser_id = Html::getUniqueId(implode('-', $id_components));
    }
  }

  $form['brandfolder_browser'] = [
    '#type' => 'fieldset',
    '#collabsible' => FALSE,
    '#prefix' => "<div id=\"$bf_browser_id\" class=\"brandfolder-browser\" data-selection-limit=\"{$selection_limit}\">",
    '#suffix' => "</div>",
  ];
  $form['brandfolder_browser']['brandfolder_browser_id'] = [
    '#type' => 'hidden',
    '#value' => $bf_browser_id,
  ];
  $form['brandfolder_browser']['brandfolder_browser_selection_limit'] = [
    '#type' => 'hidden',
    '#value' => $selection_limit,
  ];
  $form['brandfolder_browser']['brandfolder_browser_controls'] = [
    '#type' => 'fieldset',
    '#collabsible' => FALSE,
    '#attributes' => [
      'class' => [
        'brandfolder-browser-controls',
      ],
    ],
  ];

  $controls = brandfolder_browser_controls($gatekeeper, $bf_browser_id, $form, $form_state);
  $form['brandfolder_browser']['brandfolder_browser_controls'] += $controls;

  $form['brandfolder_browser']['brandfolder_browser_assets'] = [
    '#markup' => "<div class=\"brandfolder-assets\">
                    $bf_asset_list
                  </div>",
  ];

  $gatekeeper_criteria = $gatekeeper->getCriteria(FALSE);

  $form['brandfolder_browser']['bf_gatekeeper_criteria'] = [
    '#type' => 'hidden',
    '#value' => json_encode($gatekeeper_criteria),
  ];
}

/**
 * Helper function to convert an array of assets provided by the Brandfolder
 * API/SDK into an HTML list.
 *
 * @param object $assets
 * @param array $disabled_attachment_ids
 * @param array $selected_attachment_ids
 *
 * @return string
 *
 * @todo: Theme pattern, tpl, etc.
 */
function brandfolder_format_asset_list(object $assets, array $disabled_attachment_ids = [], array $selected_attachment_ids = []): string {
  $bf_asset_list_items = array_map(function ($asset) use ($disabled_attachment_ids, $selected_attachment_ids) {
    $output = '';
    if (!empty($asset->attachments)) {
      $output = "<li class=\"brandfolder-asset\" data-bf-asset-id=\"{$asset->id}\">"
        .         "<span class=\"brandfolder-asset__close_button\">&#8592;</span>"
        .         "<div class=\"brandfolder-asset__overview\">"
        .           "<h2 class=\"brandfolder-asset__heading\">{$asset->attributes->name}</h2>"
        .           "<figure>"
        .             "<img class=\"brandfolder-asset__thumb\" src=\"{$asset->attributes->thumbnail_url}\" />"
        .             "<figcaption class=\"brandfolder-asset__info\">"
        .               "<div class=\"bf-asset-metadata bf-asset-metadata--name\">{$asset->attributes->name}</div>"
        .               "<div class=\"bf-asset-metadata bf-asset-metadata--description\">{$asset->attributes->description}</div>"
        .             "</figcaption>"
        .           "</figure>"
        .          "</div>"
        .         "<div class=\"brandfolder-asset__attachments\">"
        .           "<h3 class=\"brandfolder-asset__attachment-list-heading\">" . t('Attachments') . "</h3>"
        .           "<ul class=\"brandfolder-asset__attachment-list\">";

      // Exclude unsupported attachment types (which would be returned if
      // their parent asset has other attachments that are of a supported type).
      // @todo: Sync with media type config.
      $supported_mimetypes = [
        'image/gif',
        'image/jpeg',
        'image/png',
        'image/svg+xml',
        'image/tiff',
        'image/webp',
      ];

      foreach ($asset->attachments as $attachment_id => $attachment) {
        if (!in_array($attachment->mimetype, $supported_mimetypes)) {
          continue;
        }
        $attachment_classes_array = ['brandfolder-attachment'];
        if (in_array($attachment_id, $disabled_attachment_ids)) {
          $attachment_classes_array[] = 'brandfolder-attachment--disabled';
        }
        if (in_array($attachment_id, $selected_attachment_ids)) {
          $attachment_classes_array[] = 'brandfolder-attachment--selected';
        }
        $attachment_classes = implode(' ', $attachment_classes_array);
        $output .= "<li class=\"$attachment_classes\" data-bf-attachment-id=\"{$attachment_id}\">"
          .     "<figure>"
          .       "<img class=\"brandfolder-attachment__image\" src=\"\" data-img-src=\"{$attachment->thumbnail_url}\" />"
          .       "<figcaption>"
          .         "<div class=\"bf-attachment-metadata\"><strong>" . t('Filename') . ":</strong> {$attachment->filename}</div>"
          .         "<div class=\"bf-attachment-metadata\"><strong>" . t('File Size') . ":</strong> " . format_size($attachment->size) . "</div>"
          .         "<div class=\"bf-attachment-metadata\"><strong>" . t('Dimensions') . ":</strong> {$attachment->width}x{$attachment->height}</div>"
          .       "</figcaption>"
          .     "</figure>"
          .   "</li>";
      }
      $output .= "</ul>"
        .     "</div>"
        .   "</li>";
    }

    return $output;
  }, $assets->data);

  $bf_asset_list = '<ul class="brandfolder-asset-list">' . implode(' ', $bf_asset_list_items) . '</ul>';

  return $bf_asset_list;
}

/**
 * Helper function to generate form elements to allow users to search for,
 * filter, sort, etc. assets in a Brandfolder browser context.
 *
 * @param \Drupal\brandfolder\Service\BrandfolderGatekeeper $gatekeeper
 * @param string $bf_browser_id
 * @param array $form
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *
 * @return array
 */
function brandfolder_browser_controls(BrandfolderGatekeeper $gatekeeper, string $bf_browser_id, array &$form, FormStateInterface &$form_state): array {
  $controls = [];

  $all_user_input = $form_state->getUserInput();

  if (isset($form['#action'])) {
    // These AJAX requests will always post to the $form['#action'] URL, if one
    // exists. Ensure that our URL has certain query params so that the AJAX
    // submissions are handled properly.
    // @see This core issue and related discussion: https://www.drupal.org/project/drupal/issues/2504115.
    $ajax_form_request_param = FormBuilderInterface::AJAX_FORM_REQUEST;
    try {
      $url = Url::fromUserInput($form['#action']);
      $url->mergeOptions([
        'query' => [
          $ajax_form_request_param => 1,
          'form_id'                => $form['#form_id']
        ]
      ]);
      $url = $url->toString();
    } catch (\InvalidArgumentException $e) {
      $url = $form['#action'];
      if (!(strpos($url, '?') > 0)) {
        $url .= '?';
      }
      else {
        $url .= '&';
      }
      $params = [];
      if (!(strpos($url, FormBuilderInterface::AJAX_FORM_REQUEST) > 0)) {
        $params[] = "{$ajax_form_request_param}=1";
      }
      if (!(strpos($url, 'form_id') > 0)) {
        $params[] = "form_id={$form['#form_id']}";
      }
      if (count($params) > 0) {
        $url .= implode('&', $params);
      }
    }
    $form['#action'] = $url;
  }

  $ajax_defaults = [
    'callback' => [
      'Drupal\brandfolder\Controller\AssetFetchController',
      'assetFetchFormAjaxCallback',
    ],
    'wrapper' => $bf_browser_id,
    'progress' => [
      'type' => 'throbber',
      'message' => t('Searching...'),
    ],
  ];
  if (isset($url)) {
    $ajax_defaults['url'] = $url;
  }

  $attribute_defaults = [
    'class' => [
      'brandfolder-browser-control'
    ]
  ];

  $controls['search'] = [
    '#type' => 'fieldset',
    '#collapsible' => FALSE,
    '#attributes' => [
      'class' => [
        'brandfolder-browser-control-group',
        'brandfolder-browser-control-group--search',
      ],
    ],
  ];

  $ajax = $ajax_defaults;
  $ajax['event'] = 'change';
  $controls['search']['brandfolder_controls_search_text'] = [
    '#type' => 'search',
    '#length' => 120,
    '#ajax' => $ajax,
    '#attributes' => $attribute_defaults,
  ];

  $controls['search']['brandfolder_controls_search_submit'] = [
    '#type' => 'button',
    '#value' => t('Search'),
    '#ajax' => $ajax_defaults,
    '#attributes' => $attribute_defaults,
    '#limit_validation_errors' => [],
  ];

  // Get all possible collections. If there are more than one, allow users to
  // filter by collection.
  $allowed_collections = $gatekeeper->getCollections();
  if (count($allowed_collections) > 1) {
    $controls['collections'] = [
      '#type' => 'fieldset',
      '#title' => t('Collections'),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
      '#attributes' => [
        'class' => [
          'brandfolder-browser-control-group',
          'brandfolder-browser-control-group--collections',
        ],
      ],
    ];
    foreach ($allowed_collections as $collection_id => $collection_name) {
      $controls['collections']["brandfolder_controls_collection_key_$collection_id"] = [
        '#type'       => 'checkbox',
        '#title'      => $collection_name,
        '#ajax'       => $ajax_defaults,
        '#attributes' => $attribute_defaults,
      ];
    }
  }

  // Get all possible sections. If there are more than one, allow users to
  // filter by section.
  $allowed_sections = $gatekeeper->getSections();
  if (count($allowed_sections) > 1) {
    $controls['sections'] = [
      '#type' => 'fieldset',
      '#title' => t('Sections'),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
      '#attributes' => [
        'class' => [
          'brandfolder-browser-control-group',
          'brandfolder-browser-control-group--sections',
        ],
      ],
    ];
    foreach ($allowed_sections as $section_id => $section_name) {
      $controls['sections']["brandfolder_controls_section_key_$section_id"] = [
        '#type'       => 'checkbox',
        '#title'      => $section_name,
        '#ajax'       => $ajax_defaults,
        '#attributes' => $attribute_defaults,
      ];
    }
  }

  // Get all possible labels. If there are more than one, allow users to
  // filter by label.
  $allowed_labels_tree = $gatekeeper->getLabels();
  $label_options = [];
  brandfolder_build_labels_select_list($allowed_labels_tree, $label_options);
  if (count($label_options) > 1) {
    $controls['labels'] = [
      '#type'        => 'fieldset',
      //    '#title' => t('Labels'),
      '#collapsible' => TRUE,
      '#collapsed'   => TRUE,
      '#attributes'  => [
        'class' => [
          'brandfolder-browser-control-group',
          'brandfolder-browser-control-group--labels',
        ],
      ],
    ];
    $attributes = $attribute_defaults;
    $attributes['size'] = min(count($label_options), 10);
    $controls['labels']['brandfolder_controls_labels'] = [
      '#type' => 'select',
      '#title' => t('Labels'),
      '#attributes' => $attributes,
      '#ajax'       => $ajax_defaults,
      '#options' => $label_options,
      '#multiple' => TRUE,
    ];
  }

  // Orientation/aspect.
  $controls['orientation'] = [
    '#type'        => 'fieldset',
    '#title' => t('Orientation'),
    '#collapsible' => TRUE,
    '#collapsed'   => TRUE,
    '#attributes'  => [
      'class' => [
        'brandfolder-browser-control-group',
        'brandfolder-browser-control-group--orientation',
      ],
    ],
  ];
  $orientation_options = [
    'landscape' => t('Horizontal'),
    'portrait' => t('Vertical'),
    'square' => t('Square'),
    'panorama' => t('Panoramic'),
  ];
  foreach ($orientation_options as $key => $label) {
    $controls['orientation']["brandfolder_controls_aspect_$key"] = [
      '#type'       => 'checkbox',
      '#title'      => $label,
      '#ajax'       => $ajax_defaults,
      '#attributes' => $attribute_defaults,
    ];
  }

  // File type.
  // @todo: maintain a registry of file types that are actually used and popular for the given Brandfolder and use those.
  $controls['filetype'] = [
    '#type'        => 'fieldset',
    '#title' => t('Popular File Types'),
    '#collapsible' => TRUE,
    '#collapsed'   => TRUE,
    '#attributes'  => [
      'class' => [
        'brandfolder-browser-control-group',
        'brandfolder-browser-control-group--filetype',
      ],
    ],
  ];
  $filetype_options = [
    'jpg',
    'png',
    'svg',
    'gif',
    'webp',
//    'mp4',
  ];
  foreach ($filetype_options as $type) {
    $controls['filetype']["brandfolder_controls_filetype_$type"] = [
      '#type'       => 'checkbox',
      '#title'      => $type,
      '#ajax'       => $ajax_defaults,
      '#attributes' => $attribute_defaults,
    ];
  }

  // Upload recency.
  $controls['upload_date'] = [
    '#type'        => 'fieldset',
    '#collapsible' => TRUE,
    '#collapsed'   => TRUE,
    '#attributes'  => [
      'class' => [
        'brandfolder-browser-control-group',
        'brandfolder-browser-control-group--upload-date',
      ],
    ],
  ];
  $controls['upload_date']['brandfolder_controls_upload_date'] = [
    '#type'       => 'radios',
    '#title'      => t('Upload Date'),
    '#options'    => [
      'all'        => t('All'),
      '30m' => t('Last 30 Minutes'),
      '1d'   => t('Last 24 Hours'),
      '7d'     => t('Last 7 Days'),
      '30d'    => t('Last 30 Days'),
    ],
    '#ajax'       => $ajax_defaults,
    '#attributes' => $attribute_defaults,
  ];

  // Tags.
  $controls['tags'] = [
    '#type'        => 'fieldset',
    '#title' => t('Tags'),
    '#collapsible' => TRUE,
    '#collapsed'   => TRUE,
    '#attributes'  => [
      'class' => [
        'brandfolder-browser-control-group',
        'brandfolder-browser-control-group--tags',
      ],
    ],
  ];
  // Allow users to choose whether the selected tags should be combined
  // inclusively or exclusively.
  $controls['tags']['brandfolder_controls_tag_filter_mode'] = [
    '#type'       => 'radios',
    '#options'      => [
      'any' => t('Any selected'),
      'all' => t('All selected'),
    ],
    '#default_value'       => 'any',
    '#ajax'       => $ajax_defaults,
    '#attributes' => $attribute_defaults,
    '#prefix' => '<div class="brandfolder-browser-controls__tag-filter-mode">',
    '#suffix' => '</div>',
  ];
  $controls['tags']['tag_list'] = [
    '#type'        => 'fieldset',
    '#collapsible' => FALSE,
    '#attributes'  => [
      'class' => [
        'brandfolder-browser-controls__tag_list',
      ],
    ],
  ];
  $num_tag_checkboxes = 0;
  $tag_key_mapping_string = $form_state->getValue('brandfolder_controls_tag_key_mapping');
  if (empty($tag_key_mapping_string)) {
    if (isset($all_user_input['brandfolder_controls_tag_key_mapping'])) {
      $tag_key_mapping_string = $all_user_input['brandfolder_controls_tag_key_mapping'];
    }
  }
  $tag_key_mapping = empty($tag_key_mapping_string) ? [] : json_decode($tag_key_mapping_string, TRUE);
  foreach ($tag_key_mapping as $tag_key => $tag_name) {
    $controls['tags']['tag_list']["brandfolder_controls_tags_$tag_key"] = [
      '#type'       => 'checkbox',
      '#title'      => $tag_name,
      '#ajax'       => $ajax_defaults,
      '#attributes' => $attribute_defaults,
    ];
    $num_tag_checkboxes++;
  }

  $tag_text_input_should_be_cleared = FALSE;

  $new_tag_name = $form_state->getValue('brandfolder_controls_tag_text_input');
  if (empty($new_tag_name)) {
    if (isset($all_user_input['brandfolder_controls_tag_text_input'])) {
      $new_tag_name = $all_user_input['brandfolder_controls_tag_text_input'];
    }
  }
  // If the user has just entered the name of a tag to use in filtering...
  if (!empty($new_tag_name)) {
    // Declare that the text input field should be cleared/reset.
    $tag_text_input_should_be_cleared = TRUE;
    // Generate a reliable key that can be mapped to the tag's human-readable
    // name.
    $tag_key = md5($new_tag_name);
    // Add a (pre-checked) checkbox to the form for filtering results by the
    // given tag. Users will then be able to uncheck it as desired. Such
    // checkboxes will persist for the life of the Brandfolder browser form,
    // whether checked or unchecked.
    $tag_checkbox_identifier = "brandfolder_controls_tags_$tag_key";
    $controls['tags']['tag_list'][$tag_checkbox_identifier] = [
      '#type'       => 'checkbox',
      '#default_value' => TRUE,
      '#title'      => $new_tag_name,
      '#ajax'       => $ajax_defaults,
      '#attributes' => $attribute_defaults,
    ];
    $num_tag_checkboxes++;
    // Ensure that the dynamically-generated checkbox has a positive value
    // for immediate processing. Technically, this may be more suited to a
    // validation function, but keep it here for now for clarity.
    $form_state->setValue($tag_checkbox_identifier, TRUE);
    $all_user_input[$tag_checkbox_identifier] = TRUE;
    $form_state->setUserInput($all_user_input);
    // Add the new tag to our key:name mapping.
    $tag_key_mapping[$tag_key] = $new_tag_name;
  }

  // If there are no tag checkboxes at this time, remove the container and
  // tag filter mode selector.
  if ($num_tag_checkboxes == 0) {
    unset($controls['tags']['tag_list']);
    unset($controls['tags']['brandfolder_controls_tag_filter_mode']);
  }

  $controls['tags']['new_tag_input_group'] = [
    '#type'        => 'fieldset',
    '#collapsible' => FALSE,
    '#attributes'  => [
      'class' => [
        'brandfolder-browser-controls__new_tag_input_group',
      ],
    ],
  ];
  $ajax = $ajax_defaults;
  $ajax['event'] = 'change';
  $attributes = $attribute_defaults;
  $attributes['class'][] = 'brandfolder-browser-control--tag-text-input';
  $controls['tags']['new_tag_input_group']['brandfolder_controls_tag_text_input'] = [
    '#type' => 'textfield',
    '#length' => 120,
    '#ajax' => $ajax,
    '#attributes' => $attributes,
  ];
  if ($tag_text_input_should_be_cleared) {
    $controls['tags']['new_tag_input_group']['brandfolder_controls_tag_text_input']['#value'] = '';
  }
  $controls['tags']['new_tag_input_group']['brandfolder_controls_tag_text_input_submit'] = [
    '#type' => 'button',
    '#value' => t('Add'),
    '#ajax' => $ajax_defaults,
    '#attributes' => $attribute_defaults,
    '#limit_validation_errors' => [],
  ];

  $controls['brandfolder_controls_tag_key_mapping'] = [
    '#type' => 'hidden',
    '#value' => json_encode($tag_key_mapping),
    '#attributes' => [
      'class' => [
        'brandfolder-controls-tag-key-mapping',
      ]
    ],
  ];

  // Sorting.
  $controls['sort'] = [
    '#type'        => 'fieldset',
    //    '#title' => t('Sort'),
    '#collapsible' => TRUE,
    '#collapsed'   => TRUE,
    '#attributes'  => [
      'class' => [
        'brandfolder-browser-control-group',
        'brandfolder-browser-control-group--sort',
      ],
    ],
  ];
  $controls['sort']['brandfolder_controls_sort_criterion'] = [
    '#title'         => t('Sort by'),
    '#type'          => 'select',
    '#options'       => [
      'name'       => t('Name'),
      'score'      => t('Score'),
      'position'   => t('Position'),
      'updated_at' => t('Updated'),
      'created_at' => t('Upload Date'),
    ],
    '#default_value' => 'created_at',
    '#ajax'          => $ajax_defaults,
    '#attributes'    => $attribute_defaults,
  ];
  $controls['sort']['brandfolder_controls_sort_order'] = [
    '#title'         => t('Sort Order'),
    '#type'          => 'select',
    '#options'       => [
      'asc'  => t('Ascending'),
      'desc' => t('Descending'),
    ],
    '#default_value' => 'desc',
    '#ajax'          => $ajax_defaults,
    '#attributes'    => $attribute_defaults,
  ];

  return $controls;
}

/**
 * Recursive function to generate nested select list from label tree.
 *
 * @param $labels
 * @param $select_options
 */
function brandfolder_build_labels_select_list($labels, &$select_options) {
  foreach ($labels as $id => $data) {
    $label = $data['label'];
    // Add this label to the list, indented according to depth.
    $display_value = '';
    $label_depth = $label->attributes->depth;
    if ($label_depth > 1) {
      for ($i = 1; $i < $label_depth; $i++) {
        $display_value .= '-';
      }
      $display_value .= ' ';
    }
    $display_value .= $label->attributes->name;
    $select_options[$label->id] = $display_value;

    // Recurse through any children/descendants.
    if (isset($data['children']) && is_array($data['children'])) {
      brandfolder_build_labels_select_list($data['children'], $select_options);
    }
  }
}

/**
 * Check to see whether a form submission was triggered by one of our
 * Brandfolder browser controls (e.g. search, filters, etc.).
 *
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *
 * @return bool
 */
function is_form_submission_triggered_by_bf_browser_controls(FormStateInterface $form_state): bool {
  $triggering_element = $form_state->getTriggeringElement();
  if (isset($triggering_element['#attributes']['class'])) {
    $classes = $triggering_element['#attributes']['class'];
    if (is_array($classes) && in_array('brandfolder-browser-control', $classes)) {
      return TRUE;
    }
  }

  return FALSE;
}
/**
 * Form validation handler to be applied to forms containing a Brandfolder
 * Browser, after other validation handlers have executed.
 *
 * @param array $form
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 */
function brandfolder_browser_host_form_validator(array &$form, \Drupal\Core\Form\FormStateInterface &$form_state) {
  // If the submission was triggered by one of our browser controls, the only
  // outcome should be to update the browser contents. We do not care about
  // other validation logic/errors.
  if (is_form_submission_triggered_by_bf_browser_controls($form_state)) {
    $form_state->clearErrors();
  }
}

/**
 * Helper function to translate Brandfolder browser selections to Drupal form
 * values in a Media Library context. To be used as a form validation handler.
 *
 * @param array $form
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 */
function brandfolder_browser_to_media_library_selection_converter(array &$form, \Drupal\Core\Form\FormStateInterface &$form_state) {
  // We don't need or want to perform validation when the submission is
  // triggered by one of our browser controls.
  if (is_form_submission_triggered_by_bf_browser_controls($form_state)) {

    return;
  }

  $selected_media_entities = [];
  $selected_media_entities_list = '';
  $selected_attachment_list = $form_state->getValue('selected_bf_attachment_ids');
  if (!empty($selected_attachment_list)) {
    $selected_attachments = explode(',', $selected_attachment_list);
    // Determine the relevant media type from the form ID.
    if (preg_match('/^views_form_media_library_widget_(.+)$/', $form['#form_id'], $matches)) {
      $media_type_id = $matches[1];
      $selected_media_entities = array_map(function ($attachment_id) use ($media_type_id) {
        return brandfolder_map_attachment_to_media_entity($attachment_id, $media_type_id);
      }, $selected_attachments);
      $selected_media_entities_list = implode(',', $selected_media_entities);
    }
  }
  $media_select_form_values = array_combine($selected_media_entities, $selected_media_entities);
  $form_state->setValue('media_library_select_form', $media_select_form_values);
  $form_state->setValue('media_library_select_form_selection', $selected_media_entities_list);
}

/**
 * Implements hook_theme().
 */
function brandfolder_theme() {
  return [
    'brandfolder_browser_widget' => [
      'render element' => 'element',
    ],
  ];
}

/**
 * Prepares variables for Brandfolder Browser widget templates.
 *
 * Default template: brandfolder-browser-widget.html.twig.
 *
 * @param array $variables
 *   An associative array containing:
 *   - element: A render element representing the Brandfolder Browser widget.
 */
function template_preprocess_brandfolder_browser_widget(&$variables) {
  $element = $variables['element'];

  $variables['attributes'] = ['class' => ['brandfolder-browser-widget', 'js-form-managed-file', 'form-managed-file', 'clearfix']];

  $variables['data'] = [];
  foreach (Element::children($element) as $child) {
    $variables['data'][$child] = $element[$child];
  }
}

/**
 * Given a Brandfolder attachment, return a Drupal file ID.
 *
 * If no managed file yet exists in Drupal for the given attachment, attempt to
 * create one.
 *
 * @param string|object $attachment
 *   Unique Brandfolder attachment ID, or an object representing a Brandfolder
 *   attachment. Objects must include the attachment ID, CDN URL, and parent
 *   asset ID.
 * @param bool $create_new_file
 *   If TRUE, and no Drupal file exists for the given attachment, create a new
 *   Drupal file entity and link it to the attachment.
 *
 * @return bool|int
 *   The file ID on success; FALSE on failure.
 *
 * @throws \GuzzleHttp\Exception\GuzzleException
 *
 * @todo Move to class.
 */
function brandfolder_map_attachment_to_file($attachment, $create_new_file = TRUE) {
  $fid = FALSE;

  $logger = \Drupal::logger('brandfolder');

  $attachment_id = is_string($attachment) ? $attachment : $attachment->id;

  $db = \Drupal::database();
  $query = $db->select('brandfolder_file', 'bf')
    ->fields('bf', ['fid'])
    ->condition('bf_attachment_id', $attachment_id);
  if ($query->countQuery()->execute()->fetchField()) {
    $result = $query->execute();
    $fid = $result->fetch()->fid;
  }
  elseif ($create_new_file) {
    $bf = brandfolder_api();
    $params = [
      'fields' => 'cdn_url',
      'include' => 'asset',
    ];
    if (is_string($attachment)) {
      if ($attachment = $bf->fetchAttachment($attachment_id, $params)) {
        $attachment = $attachment->data;
      }
    }
    if ($bf->verboseLoggingIsEnabled()) {
      foreach ($bf->getLogData() as $log_entry) {
        $logger->debug($log_entry);
      }
      $bf->clearLogData();
    }
    if ($attachment) {
      if (!empty($attachment->relationships->asset)) {
        $asset_id = $attachment->relationships->asset->data->id;
      }
      else {
        $logger->error('Could not determine the asset for the attachment with ID !attachment_id', ['!attachment_id' => $attachment_id]);

        return FALSE;
      }
      $file_data = [
        // Note: Start with 0 (temporary) file status, which will be changed to
        // 1 (permanent) by the File module if/when the host entity is saved.
        // File module will also create a file_usage record.
        // @todo: If the file is never made permanent, remove its brandfolder_file record? Or see if we can just jump straight to permanent status? That might run afoul of file/entity reference validation.
        'status' => 0,
        'uid' => \Drupal::currentUser()->id(),
      ];
      $bf_file_data = [
        'bf_attachment_id' => $attachment_id,
        'bf_asset_id' => $asset_id,
        'timestamp' => \Drupal::time()->getRequestTime(),
      ];
      $cdn_url = $attachment->attributes->cdn_url;
      $info = brandfolder_parse_cdn_url($cdn_url);
      $bf_file_data['cdn_id'] = $info['cdn_id'];

      $filename = $attachment->attributes->filename;
      $mime_type = $attachment->attributes->mimetype;
      $mimetype_handler = \Drupal::getContainer()
        ->get('file.mime_type.guesser.brandfolder');
      if (empty($mime_type)) {
        if (!$mime_type = $mimetype_handler->guessMimeTypeFromExtension($filename)) {
          $logger->error('Attempting to map an attachment to a Drupal file but this attachment appears not to have a mimetype (attachment ID !attachment_id).', ['!attachment_id' => $attachment_id]);

          return FALSE;
        }
      }
      $file_data['filemime'] = $bf_file_data['mime_type'] = $mime_type;

      // Consider scenarios where this metadata is (temporarily) unavailable
      // due to delays in processing files for a recently created/updated
      // attachment.
      if (is_null($attachment->attributes->size) || is_null($attachment->attributes->width) || is_null($attachment->attributes->height)) {
        $logger->error('Attempting to map an attachment to a Drupal file but this attachment appears not to have the necessary file size data (attachment ID !attachment_id).', ['!attachment_id' => $attachment_id]);

        return FALSE;
      }
      $bf_file_data['filesize'] = $attachment->attributes->size;
      $bf_file_data['width'] = $attachment->attributes->width;
      $bf_file_data['height'] = $attachment->attributes->height;

      $uri = $info['uri'];
      // If the attachment has a mime type but its filename has no extension,
      // add an appropriate extension to the Drupal file's filename.
      if (!preg_match('/\.[^\.]+$/', $filename)) {
        if ($extension = $mimetype_handler->getExtensionFromMimetype($mime_type)) {
          $filename .= '.' . $extension;
          // Be sure to use that same extension in the URI so we can reliably
          // look up files by URI later. The regex op below will update the URI
          // to use that extension whether it already has an extension or not.
          $uri = preg_replace('/([^\.]+)(\.[^\.]+)?$/', "$1.$extension", $uri);
        }
      }
      $file_data['filename'] = $filename;
      $file_data['uri'] = $bf_file_data['uri'] = $uri;

      // Store data in the brandfolder_file table before saving the file, so
      // we can use it to look up things like filesize when the file is being
      // saved.
      $db->insert('brandfolder_file')
        ->fields($bf_file_data)
        ->execute();

      try {
        $file = File::Create($file_data);
        $file->save();
        $fid = $bf_file_data['fid'] = $file->id();

        // Update the brandfolder_file table with the newly created FID.
        $result = $db->merge('brandfolder_file')
          ->key([
            'uri'         => $uri,
            'bf_attachment_id' => $attachment_id,
            'bf_asset_id' => $asset_id,
          ])
          ->fields(['fid' => $fid])
          ->execute();
        if ($result != Database\Query\Merge::STATUS_UPDATE) {
          $logger->error('Could not find an existing record in the brandfolder_file table for attachment ID !attachment_id and file ID !fid.', [
            '!fid'      => $fid,
            '!attachment_id' => $attachment_id
          ]);
        }

        \Drupal::moduleHandler()->invokeAll('brandfolder_file_insert', [
          $file,
          $attachment_id
        ]);
      }
      catch (EntityStorageException $e) {
        $logger->error('There was an error saving a new file for Brandfolder attachment !attachment_id.', ['!attachment_id' => $attachment_id]);
      }
    }
  }

  return $fid;
}

/**
 * Given a Brandfolder attachment, return a Drupal media entity ID.
 *
 * If no media entity yet exists for the given attachment, attempt to
 * create one.
 *
 * @param string|object $attachment
 *    Unique Brandfolder attachment ID, or an object representing a Brandfolder
 *    attachment.
 * @param bool $create_new_entity
 *    If TRUE, and no Drupal media entity exists for the given attachment,
 *    create a new media entity and link it to the attachment.
 *
 * @return bool|int
 *   The media entity ID on success; FALSE on failure.
 */
function brandfolder_map_attachment_to_media_entity($attachment, $media_type_id, $create_new_entity = TRUE) {
  $entity_id = FALSE;

  $logger = \Drupal::logger('brandfolder');

  $attachment_id = is_string($attachment) ? $attachment : $attachment->id;
  // @todo: Global constant, config, etc.?
  $bf_media_source_field_name = 'field_brandfolder_attachment_id';

  // Check to see if a media entity of the given type already exists for this
  // BF attachment.
  $results = \Drupal::entityQuery('media')
    ->condition('bundle', $media_type_id)
    ->condition($bf_media_source_field_name, $attachment_id)
    ->range(0, 1)
    ->accessCheck(FALSE)
    ->execute();

  if (!empty($results)) {
    $entity_id = reset($results);
  }
  elseif ($create_new_entity) {
    if ($attachment_id) {
      $bf_client = brandfolder_api();
      try {
        // Generate a default name.
        // @todo: Improve on this by allowing admins to configure patterns for auto-created entity names?
        $default_name = "Auto-Created Entity for Brandfolder Attachment $attachment_id";
        $asset = FALSE;
        if ($attachment = $bf_client->fetchAttachment($attachment_id, ['include' => 'asset'])) {
          $asset_id = $attachment->data->relationships->asset->data->id ?? FALSE;
          if ($asset_id) {
            $asset = $bf_client->fetchAsset($asset_id);
          }
          $default_name = $asset ? "{$asset->data->attributes->name} - {$attachment->data->attributes->filename}" : $attachment->data->attributes->filename;
        }
        $media = Media::create([
          'name' => $default_name,
          'bundle' => $media_type_id,
          $bf_media_source_field_name => $attachment_id,
        ]);
        $media->save();
        $entity_id = $media->id();
      }
      catch (EntityStorageException $e) {
        $logger->error('There was an error saving a new media entity for Brandfolder attachment !attachment_id.', ['!attachment_id' => $attachment_id]);
      }
      if ($bf_client->verboseLoggingIsEnabled()) {
        foreach ($bf_client->getLogData() as $log_entry) {
          $logger->debug($log_entry);
        }
        $bf_client->clearLogData();
      }
    }
  }

  return $entity_id;
}

/**
 * Given a Drupal media entity ID, return a Brandfolder attachment ID.
 *
 * @param int $media_entity_id
 *
 * @return bool|string
 *   The attachment ID on success; FALSE on failure.
 */
function brandfolder_map_media_entity_to_attachment(int $media_entity_id) {
  $attachment_id = FALSE;
  if ($media = \Drupal::entityTypeManager()->getStorage('media')->load($media_entity_id)) {
    // @todo: Global constant, config, etc.?
    $bf_media_source_field_name = 'field_brandfolder_attachment_id';
    $field_item_list = $media->get($bf_media_source_field_name);
    if ($field_item_list->count() > 0) {
      $attachment_id = $field_item_list->first()->getValue()['value'];
    }
  }

  if (!$attachment_id) {
    $logger = \Drupal::logger('brandfolder');
    $logger->error('Could not determine a Brandfolder attachment ID for media entity ID !media_entity_id', ['!media_entity_id' => $media_entity_id]);
  }

  return $attachment_id;
}

/**
 * Helper function to map an attachment ID to an asset ID, prioritizing our
 * local registry (which is updated on asset.update webhook events).
 *
 * @param string $attachment_id
 *
 * @return string|bool
 */
function brandfolder_get_asset_from_attachment(string $attachment_id) {
  $asset_id = FALSE;

  $db = \Drupal::database();
  $query = $db->select('brandfolder_file', 'bf')
    ->fields('bf', ['bf_asset_id'])
    ->condition('bf_attachment_id', $attachment_id);
  if ($query->countQuery()->execute()->fetchField()) {
    $result = $query->execute();
    $asset_id = $result->fetch()->bf_asset_id;
  }
  else {
    // If we don't have a local record of this attachment, try to fetch it
    // from the Brandfolder API.
    $bf_client = brandfolder_api();
    $attachment = $bf_client->fetchAttachment($attachment_id, ['include' => 'asset']);
    if ($attachment) {
      $asset_id = $attachment->data->relationships->asset->data->id;
    }
  }

  return $asset_id;
}

/**
 * Helper function to parse a CDN URL and return useful derived data.
 *
 * @param string $cdn_url
 *   A full URL via which a Brandfolder attachment is served on the Brandfolder CDN.
 *
 * @return array
 *   Array containing the following keys:
 *   ['uri', 'cdn_id', 'id', 'filename', 'type'].
 */
function brandfolder_parse_cdn_url($cdn_url) {
  $return = [
    'uri' => '',
    'cdn_id' => '',
    'id' => '',
    'filename' => '',
    'type' => '',
    'query' => '',
  ];

  if (preg_match("/.*cdn\.(brandfolder\.io|bfldr\.com)\/(([^\/]+)\/(as|at)\/([\w\-]+)\/([^\?]+))(\?(.*))?$/", $cdn_url, $matches)) {
    $uri_suffix = $matches[2];
    $return = [
      'uri' => 'bf://' . $uri_suffix,
      'cdn_id' => $matches[3],
      'id' => $matches[5],
      'filename' => $matches[6],
      'query' => $matches[8] ?? '',
    ];
    $return['type'] = ($matches[4] == 'as') ? 'asset' : 'attachment';
  }

  return $return;
}

/**
 * Helper function to parse a Brandfolder URI and return useful derived data.
 *
 * @param string $uri
 *
 * @return bool|array
 *  If the given URI pertains to Brandfolder, return an array containing the
 *  following keys:
 *   ['cdn_id', 'id', 'type', 'filename', 'query'].
 *  Otherwise, return FALSE.
 */
function brandfolder_parse_uri(string $uri) {
  $return = FALSE;

  if (preg_match("/^bf:\/\/(styles\/(?P<image_style>[^\/]+)\/bf\/)?((?P<cdn_id>[^\/]+)\/(?P<type_id>as|at)\/(?P<id>[\w\-]+)\/(?P<filename>[^\?]*)(\?(?P<query>.*))?)$/", $uri, $matches)) {
    $defaults = [
      'image_style' => '',
      'cdn_id' => '',
      'type_id' => 'at',
      'id' => '',
      'filename' => '',
      'query' => '',
    ];
    $return = array_intersect_key($matches, $defaults) + $defaults;
    $return['type'] = ($return['type_id'] === 'as') ? 'asset' : 'attachment';
  }

  return $return;
}

/**
 * Implements hook_ENTITY_TYPE_insert().
 */
function brandfolder_media_type_insert(MediaTypeInterface $media_type) {
  // Do not alter configuration during config sync.
  // @todo
  if ($media_type->isSyncing()) {
    return;
  }
  // Create an image field on new BrandfolderImage-sourced media types.
  if ($media_type->getSource() instanceof BrandfolderImage) {
    $source = $media_type->getSource();
    $image_field_storage = FieldStorageConfig::loadByName('media', 'bf_image');
    if (!$image_field_storage) {
      $image_field_storage = $source->createImageFieldStorage();
      $image_field_storage->save();
    }

    $image_field = $source->createImageField($media_type);
    $image_field->save();
  }
}

/**
 * Implements hook_ENTITY_TYPE_delete().
 */
function brandfolder_file_delete($file) {
  // If this was a Brandfolder-related file, remove its entry from our
  // file mapping table.
  $db = \Drupal::database();
  $db->delete('brandfolder_file')
    ->condition('fid', $file->id())
    ->execute();
}

/**
 * Implements hook_ENTITY_TYPE_presave().
 *
 * @throws EntityMalformedException
 */
function brandfolder_media_presave(MediaInterface $media) {
  $source = $media->getSource();
  if ($source instanceof BrandfolderImage) {
    $logger = \Drupal::logger('brandfolder');
    $bf_attachment_id = $source->getSourceFieldValue($media);

    // Create an image field on BrandfolderImage-sourced media types if one does
    // not already exist. If one does exist, see if it could benefit from
    // Brandfolder metadata.
    $imageItem = $media->get('bf_image');
    $image_field_data = ($imageItem && $imageItem->count() > 0) ? $imageItem->first()->getValue() : [];
    $is_image_update_required = FALSE;
    $is_metadata_fetch_required = FALSE;
    if (empty($image_field_data)) {
      if (!empty($bf_attachment_id)) {
        // @todo: If changed. Dupe reconciliation, etc.
        if ($fid = brandfolder_map_attachment_to_file($bf_attachment_id)) {
          $file = File::load($fid);
          $image_field_data = [
            'target_id' => $fid,
          ];
          $is_image_update_required = TRUE;
          $is_metadata_fetch_required = TRUE;
          $image = Drupal::service('image.factory')->get($file->getFileUri());
          if ($image->isValid()) {
            $image_field_data['width'] = $image->getWidth();
            $image_field_data['height'] = $image->getHeight();
          }
        }
      }
    }
    else {
      if (empty($image_field_data['alt'])) {
        $is_metadata_fetch_required = TRUE;
      }
    }

    // Ensure that attachment maps to an asset.
    $bf_asset_id = brandfolder_get_asset_from_attachment($bf_attachment_id);
    if (!$bf_asset_id) {
      $msg = 'Could not map attachment ID @attachment_id to an asset.';
      $msg_vars = ['@attachment_id' => $bf_attachment_id];
      $logger->error($msg, $msg_vars);
      throw new EntityMalformedException(t($msg, $msg_vars));
    }

    if ($is_metadata_fetch_required) {
      // Pull alt text from Brandfolder if a custom field has been
      // designated for that.
      $config = \Drupal::config('brandfolder.settings');
      $alt_text_custom_field_id = $config->get('alt_text_custom_field');
      if (!empty($alt_text_custom_field_id)) {
        // @todo: Update per new SDK.
        $bf = brandfolder_api();
        $params = [
          'include' => 'custom_fields',
        ];
        if ($asset = $bf->fetchAsset($bf_asset_id, $params)) {
          // Look up the current name associated with the given custom field
          // key ID.
          if ($custom_field_keys = $bf->listCustomFields(NULL, FALSE, TRUE)) {
            if (isset($custom_field_keys[$alt_text_custom_field_id])) {
              $custom_field_name = $custom_field_keys[$alt_text_custom_field_id];
              if (!empty($asset->data->custom_field_values[$custom_field_name])) {
                // @todo: asset.update webhook action to update this value if it is populated in BF in the future and the Drupal field remains empty.
                $image_field_data['alt'] = $asset->data->custom_field_values[$custom_field_name];
                $is_image_update_required = TRUE;
              }
            }

          }
        }
        if ($bf->verboseLoggingIsEnabled()) {
          foreach ($bf->getLogData() as $log_entry) {
            $logger->debug($log_entry);
          }
          $bf->clearLogData();
        }
      }
    }
    if ($is_image_update_required) {
      $media->set('bf_image', $image_field_data);
    }

    // Also update the media "thumbnail" with image data if applicable.
    $thumbnail_default = ['target_id' => NULL, 'alt' => NULL, 'title' => NULL, 'width' => NULL, 'height' => NULL];
    $existing_thumbnail = $media->get('thumbnail');
    $existing_thumbnail_data = $existing_thumbnail ? $media->get('thumbnail')->first()->getValue() : $thumbnail_default;
    $new_thumbnail_data = array_intersect_key($image_field_data, $thumbnail_default);
    if ($new_thumbnail_data != $existing_thumbnail_data) {
      $media->set('thumbnail', $new_thumbnail_data);
    }


    // Enforce Brandfolder configuration defined at the media type level.
    // Any violations will typically be caught elsewhere in a more user-friendly
    // fashion (e.g. on media entity create/edit form), but we check here to
    // ensure nothing falls through the cracks during programmatic entity
    // updates, etc.
    $gatekeeper = \Drupal::getContainer()
      ->get(BrandfolderGatekeeper::class);
    $gatekeeper->loadFromMediaSource($source);
    $valid = $gatekeeper->validateBrandfolderEntities(['attachments' => [$bf_attachment_id]]);
    if (!$valid) {
      \Drupal::messenger()->addError('The asset you selected does not appear to be allowed here. Please contact an administrator for assistance.');
      $msg = $gatekeeper->getMessage();
      $logger->error($msg);
      throw new EntityMalformedException($msg);
    }
  }
}

/**
 * Implements hook_ENTITY_TYPE_delete().
 */
//function brandfolder_media_delete($media) {
//  // If this was a Brandfolder-related media entity, remove associated
//  // auto-generated files.
//  // @todo: Decide whether we want to do this. Users may explicitly want to keep those files or at least not expect this behavior. We could prompt users upon media deletion, and/or or provide a global config option dictating cascading delete behavior.
//  $source = $media->getSource();
//  // @todo: Support other BF source types if/when those are added.
//  if ($source instanceof BrandfolderImage) {
//    // Delete the file referenced by the 'bf_image' field [if it is not in use
//    // elsewhere]...
//  }
//}

/**
 * Implements hook_entity_embed_media_image_source_field_alter().
 *
 * Tell the Entity Embed module what field to use as an image "source" field
 * when dealing with BrandfolderImage media entities.
 */
function brandfolder_entity_embed_media_image_source_field_alter(&$field_name, $media) {
  $source = $media->getSource();
  $bf_image_field_name = 'bf_image';
  if ($source instanceof BrandfolderImage && $media->hasField($bf_image_field_name)) {
    $field_name = $bf_image_field_name;
  }
}

/**
 * Helper function to determine whether a given media entity is sourced from
 * Brandfolder.
 *
 * @param int|\Drupal\media\MediaInterface $media
 *  Media entity ID or object.
 *
 * @return bool
 */
function is_media_brandfolder_sourced(int | MediaInterface $media) {
  if (is_int($media)) {
    $media = Media::load($media);
  }
  if ($media instanceof MediaInterface) {
    $source = $media->getSource();

    $brandfolder_media_sources = [
      'brandfolder_image',
    ];

    return in_array($source->getPluginId(), $brandfolder_media_sources);
  }

  return FALSE;
}
